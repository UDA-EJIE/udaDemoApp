package com.ejie.aa79b.service;

import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.ejie.aa79b.common.Constants;
import com.ejie.aa79b.dao.CategExpDao;
import com.ejie.aa79b.dao.ConfigCalculoPresupuestoDao;
import com.ejie.aa79b.dao.DatosTareaTradosDao;
import com.ejie.aa79b.dao.DatosTareaTradosDocsDao;
import com.ejie.aa79b.dao.DocumentosExpedienteDao;
import com.ejie.aa79b.dao.DocumentosGeneralDao;
import com.ejie.aa79b.dao.ExpedienteTradRevDao;
import com.ejie.aa79b.dao.GenericoDao;
import com.ejie.aa79b.dao.MetadatosBusquedaDao;
import com.ejie.aa79b.dao.TareasGeneralDao;
import com.ejie.aa79b.model.CategExp;
import com.ejie.aa79b.model.ConfigCalculoPresupuesto;
import com.ejie.aa79b.model.DatosTareaTrados;
import com.ejie.aa79b.model.DatosTareaTradosDocs;
import com.ejie.aa79b.model.DocumentoTarea;
import com.ejie.aa79b.model.DocumentoTareaAdjunto;
import com.ejie.aa79b.model.ExpedienteTradRev;
import com.ejie.aa79b.model.MetadatosBusqueda;
import com.ejie.aa79b.model.SubidaTradosResponse;
import com.ejie.aa79b.model.enums.EstadoEnum;
import com.ejie.aa79b.model.trados.Task;
import com.ejie.aa79b.model.trados.Task.File;
import com.ejie.aa79b.model.trados.Task.File.MergedFiles.MergedFile;
import com.ejie.aa79b.utils.TradosUtils;
import com.ejie.aa79b.webservices.PIDService;

/**
 * DatosTareaTradosServiceImpl generated by UDA, 19-jun-2018 13:27:18.
 *
 * @author UDA
 */

@Service(value = "datosTareaTradosService")
public class DatosTareaTradosServiceImpl extends GenericoServiceImpl<DatosTareaTrados>
		implements DatosTareaTradosService {

	private static final Logger LOGGER = LoggerFactory.getLogger(DatosTareaTradosServiceImpl.class);

	@Autowired()
	private DatosTareaTradosDao datosTareaTradosDao;
	@Autowired()
	private DatosTareaTradosDocsDao datosTareaTradosDocsDao;
	@Autowired()
	private PIDService pidService;
	@Autowired()
	private TareasGeneralDao tareasGeneralDao;
	@Autowired()
	private DocumentosGeneralDao documentosGeneralDao;
	@Autowired()
	private MetadatosBusquedaDao metadatosBusquedaDao;
	@Autowired()
	private CategExpDao categExpDao;
	@Autowired()
	private DocumentosExpedienteDao documentosExpedienteDao;
	@Autowired()
	private ConfigCalculoPresupuestoDao configCalculoPresupuestoDao;
	@Autowired()
	private ExpedienteTradRevDao expedienteTradRevDao;
	@Autowired()
	private ReloadableResourceBundleMessageSource messageSource;

	@Override
	protected GenericoDao<DatosTareaTrados> getDao() {
		return this.datosTareaTradosDao;
	}

	/**
	 *
	 * @param idTarea BigDecimal
	 * @param fichero MultipartFile
	 * @return SubidaTradosResponse
	 */
	@Override()
	public SubidaTradosResponse subirTrados(BigDecimal idTarea, MultipartFile fichero, String indPresupuesto, Long anyo,
			Integer numExp) {
		SubidaTradosResponse resul = new SubidaTradosResponse();
		// Se recupera el registro de la 88-90 para comprobar si ya existe un
		// documento Trados para la tarea
		DocumentoTarea docTarea = new DocumentoTarea();
		docTarea.setIdTarea(idTarea);
		docTarea = this.tareasGeneralDao.findRegTrados(docTarea);

		DocumentoTareaAdjunto bean = new DocumentoTareaAdjunto();
		bean.setEncriptado(Constants.NO);

		final String nombreFichero = fichero.getOriginalFilename();
		final int elPunto = nombreFichero.lastIndexOf('.');

		final Locale locale = new Locale(Constants.LANG_EUSKERA);

		try {
			bean.setNombre(nombreFichero);
			bean.setExtension(nombreFichero.substring(elPunto + Constants.UNO, nombreFichero.length()));
			bean.setTamano(fichero.getSize());
			bean.setContentType(fichero.getContentType());
			bean.setIdTarea(idTarea);

			JAXBContext context = JAXBContext.newInstance(Task.class);
			Unmarshaller un = context.createUnmarshaller();
			// convert to desired object
			final Task task = (Task) un.unmarshal(fichero.getInputStream());

			// Se comprueba si el fichero de trados es válido para el expediente
			// seleccionado
			if (TradosUtils.esProyectoTradosValido(task.getTaskInfo().getProject().getName(),
					docTarea.getDocumentoOriginal().getAnyo(), docTarea.getDocumentoOriginal().getNumExp())) {
				// Se guarda el documento en el PID y en la 88
				this.guardarDocumento(docTarea, bean, nombreFichero, fichero.getBytes());

				// Eliminar-Añadir en la 90
				this.actualizarTareaTrados(docTarea, task, bean);

				// Eliminar-Añadir en la 91
				this.actualizarDocumentosTareaTrados(docTarea, task, idTarea);

				// Se obtienen los metadatos
				//this.actualizarMetadatosExpediente(docTarea, task); //Dejamos de recoger los metadatos del fichero de trados.

				BigDecimal presupuesto = this.calcularPresupuestoTraduccion(idTarea, indPresupuesto, anyo, numExp);
				if (Constants.SI.equals(indPresupuesto) && presupuesto != null) {
					if (presupuesto.compareTo(new BigDecimal(Constants.CERO)) == Constants.MINUS_UNO) {
						// no se ha podido calcular presupuesto
						resul.setErrorMsg(this.messageSource.getMessage("error.trados.presupuesto", null, locale));
						resul.setPresupuesto(new BigDecimal(Constants.MINUS_UNO));
					} else {
						resul.setPresupuesto(presupuesto);
						return resul;
					}

				} else {
					resul.setPresupuesto(new BigDecimal(Constants.CERO));
				}
			} else {
				// Error de validación
				resul.setErrorMsg(this.messageSource.getMessage("error.trados.proyecto", null, locale));
				resul.setPresupuesto(new BigDecimal(Constants.MINUS_UNO));
			}
		} catch (Exception e) {
			DatosTareaTradosServiceImpl.LOGGER.info("DatosTareaTradosServiceImpl : subirTrados - Error", e);
			resul.setErrorMsg(this.messageSource.getMessage("error.trados.xmlNoValido", null, locale));
			resul.setPresupuesto(new BigDecimal(Constants.MINUS_UNO));
		}

		return resul;
	}

	/**
	 *
	 * @param BigDecimal idTarea
	 * @param String     indPresupuesto
	 * @return BigDecimal
	 */
	private BigDecimal calcularPresupuestoTraduccion(BigDecimal idTarea, String indPresupuesto, Long anyo,
			Integer numExp) {
		return this.datosTareaTradosDao.calcularPresupuestoTraduccion(anyo, numExp, idTarea);
	}

	/**
	 *
	 * @param docTarea      DocumentoTarea
	 * @param bean          DocumentoTareaAdjunto
	 * @param nombreFichero String
	 * @param bytes         byte[]
	 * @throws Exception e
	 */
	public void guardarDocumento(DocumentoTarea docTarea, DocumentoTareaAdjunto bean, String nombreFichero,
			byte[] bytes) throws Exception {
		if (docTarea.getDocumentoAdjunto() != null && docTarea.getDocumentoAdjunto().getIdFichero() != null
				&& StringUtils.isNotBlank(docTarea.getDocumentoAdjunto().getOid())) {
			bean.setOid(docTarea.getDocumentoAdjunto().getOid());
			this.pidService.modifyDocumentConBytes(bean.getNombre(), bytes, bean.getOid());
			// Actualizar en la 88
			bean.setTitulo(bean.getNombre());
			bean.setIdFichero(docTarea.getDocumentoAdjunto().getIdFichero());
			this.documentosGeneralDao.update(bean);
		} else {
			if (StringUtils.isNotBlank(docTarea.getDocumentoAdjunto().getOid())) {
				this.documentosGeneralDao.remove(docTarea.getDocumentoAdjunto().getIdFichero());
			}
			// Se sube al PID
			bean.setOid(this.pidService.addDocument(nombreFichero, bytes));
			// Añadir en la 88
			bean.setTitulo(bean.getNombre());
			docTarea.setDocumentoAdjunto(this.documentosGeneralDao.add(bean));
		}
	}

	/**
	 *
	 * @param docTarea DocumentoTarea
	 * @param task     Task
	 * @return DatosTareaTrados
	 * @throws ParseException
	 */
	private DatosTareaTrados actualizarTareaTrados(DocumentoTarea docTarea, Task task, DocumentoTareaAdjunto bean)
			throws ParseException {
		final DatosTareaTrados datosTareaTrados = new DatosTareaTrados();
		datosTareaTrados.setIdTarea(docTarea.getIdTarea());
		this.datosTareaTradosDao.remove(datosTareaTrados);
		datosTareaTrados.setIdFicheroTrados(docTarea.getDocumentoAdjunto().getIdFichero());
		TradosUtils.getDatosTareaTrados(task.getBatchTotal().getAnalyse(), datosTareaTrados);
		datosTareaTrados.setNombreFicheroTrados(task.getTaskInfo().getProject().getName());
		Date temp = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").parse(task.getTaskInfo().getRunAt());
		datosTareaTrados.setFechaProyecto(temp);
		datosTareaTrados.setIndVisible(Constants.NO);
		this.datosTareaTradosDao.add(datosTareaTrados);

		// Comprobar porcentaje desviación
		this.comprobarPorcentajeDesviacion(docTarea.getDocumentoOriginal().getAnyo(),
				docTarea.getDocumentoOriginal().getNumExp(), datosTareaTrados.getNumTotalPal(), bean);

		return datosTareaTrados;

	}

	/**
	 *
	 * @param docTarea DocumentoTarea
	 * @param task     Task
	 */
	private void actualizarDocumentosTareaTrados(DocumentoTarea docTarea, Task task, BigDecimal idTarea) {
		DatosTareaTradosDocs datosTareaTradosDocs = new DatosTareaTradosDocs();
		datosTareaTradosDocs.setIdTarea(docTarea.getIdTarea());
		this.datosTareaTradosDocsDao.remove(datosTareaTradosDocs);

		// Se recuperan los documentos del expediente
		final Map<String, BigDecimal> mapaDocumentosExpediente = this.documentosExpedienteDao
				.getMapaDocumentosExpediente(docTarea.getDocumentoOriginal().getAnyo(),
						docTarea.getDocumentoOriginal().getNumExp(), idTarea);

		for (File file : task.getFile()) {
			if (!file.getName().toLowerCase().contains("." + Constants.ZIP + ".")) {
				String name = file.getName().split(TradosUtils.TIPO_ARCHIVO)[Constants.CERO];
				BigDecimal idDocOrig = mapaDocumentosExpediente.get(name);
				datosTareaTradosDocs.setIdDocOrig(idDocOrig);
				TradosUtils.getDatosTareaTradosDocs(file.getAnalyse(), datosTareaTradosDocs);
				if (datosTareaTradosDocs.getIdDocOrig() != null) {
					this.datosTareaTradosDocsDao.add(datosTareaTradosDocs);
				}
			}
			if (file.getMergedFiles() != null && file.getMergedFiles().getMergedFile() != null
					&& !file.getMergedFiles().getMergedFile().isEmpty()) {
				for (MergedFile mergeFile : file.getMergedFiles().getMergedFile()) {
					if (!mergeFile.getName().toLowerCase().contains("." + Constants.ZIP + ".")) {
						String name = mergeFile.getName().split(TradosUtils.TIPO_ARCHIVO)[Constants.CERO];
						BigDecimal idDocOrig = mapaDocumentosExpediente.get(name);
						datosTareaTradosDocs.setIdDocOrig(idDocOrig);
						TradosUtils.getDatosTareaTradosDocs(mergeFile.getAnalyse(), datosTareaTradosDocs);
						if (datosTareaTradosDocs.getIdDocOrig() != null) {
							this.datosTareaTradosDocsDao.add(datosTareaTradosDocs);
						}
					}
				}
			}
		}
		for (String nombreFichero : mapaDocumentosExpediente.keySet()) {
			if (nombreFichero.toLowerCase().contains("." + Constants.ZIP)) {
				BigDecimal idDocOrig = mapaDocumentosExpediente.get(nombreFichero);
				datosTareaTradosDocs.setIdDocOrig(idDocOrig);
				TradosUtils.getDatosTareaTradosDocs(task.getBatchTotal().getAnalyse(), datosTareaTradosDocs);
				if (datosTareaTradosDocs.getIdDocOrig() != null) {
					this.datosTareaTradosDocsDao.add(datosTareaTradosDocs);
				}
			}
		}
	}

	/**
	 *
	 * @param docTarea DocumentoTarea
	 * @param task     Task
	 */
	private void actualizarMetadatosExpediente(DocumentoTarea docTarea, Task task) {
		final List<MetadatosBusqueda> listMetadatos = TradosUtils.getListMetadatos(task);
		final CategExp categExp = new CategExp();
		categExp.setAnyo(docTarea.getDocumentoOriginal().getAnyo());
		categExp.setNumExp(docTarea.getDocumentoOriginal().getNumExp());
		for (MetadatosBusqueda metadatosBusqueda : listMetadatos) {
			// Se comprueba si ya existe
			MetadatosBusqueda result = this.metadatosBusquedaDao.buscarPorDescIgual(metadatosBusqueda);
			if (result == null) {
				metadatosBusqueda.setEstado(EstadoEnum.ALTA.getValue());
				metadatosBusqueda = this.metadatosBusquedaDao.add(metadatosBusqueda);
			} else {
				metadatosBusqueda.setId(result.getId());
			}
			categExp.setIdMetadato(metadatosBusqueda.getId());
			if (this.categExpDao.findAllCount(categExp) == Constants.CEROLONG) {
				this.categExpDao.add(categExp);
			}
		}
	}

	/**
	 *
	 * @param anyo              Long
	 * @param numExp            Integer
	 * @param numTotalPalTrados Integer
	 * @param bean              DocumentoTareaAdjunto
	 */
	public void comprobarPorcentajeDesviacion(Long anyo, Integer numExp, Integer numTotalPalTrados,
			DocumentoTareaAdjunto bean) {
		final Locale locale = new Locale(Constants.LANG_EUSKERA);
		final ConfigCalculoPresupuesto configCalculoPresupuesto = this.configCalculoPresupuestoDao
				.find(new ConfigCalculoPresupuesto(Constants.ID_DATOS_BASICOS));
		ExpedienteTradRev expedienteTradRev = new ExpedienteTradRev(anyo, numExp);
		expedienteTradRev = this.expedienteTradRevDao.find(expedienteTradRev);

		Integer numTotalPalIzo = expedienteTradRev.getNumTotalPalIzo();
		final float desviacion = numTotalPalTrados
				- (numTotalPalTrados * configCalculoPresupuesto.getPorDesviacionPal()) / Constants.CIEN;

		if (numTotalPalIzo < desviacion) {
			// Error de validación
			bean.setError(this.messageSource.getMessage("error.trados.porcentaje", null, locale));
		}
	}

}
