/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x21a.service;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.odftoolkit.odfdom.doc.OdfSpreadsheetDocument;
import org.odftoolkit.odfdom.doc.table.OdfTable;
import org.odftoolkit.odfdom.doc.table.OdfTableRow;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.ejie.x21a.dao.TableUsuarioDao;
import com.ejie.x21a.model.Usuario;
import com.ejie.x21a.model.Usuario2;
import com.ejie.x38.dto.TableRequestDto;
import com.ejie.x38.dto.TableResourceResponseDto;
import com.ejie.x38.dto.TableRowDto;
import com.ejie.x38.util.DateTimeManager;
import com.lowagie.text.Document;
import com.lowagie.text.Phrase;
import com.lowagie.text.pdf.PdfPCell;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;

/**
 * UsuarioServiceImpl generated by UDA, 14-ago-2012 12:59:39.
 * @author UDA
 */

@Service(value = "tableUsuarioService")
public class TableUsuarioServiceImpl implements TableUsuarioService {
	
	@Autowired
	private TableUsuarioDao tableUsuarioDao;
	
	/*
	 * OPERACIONES CRUD
	 */
	
	/**
	 * Inserts a single row in the Usuario table.
	 *
	 * @param usuario Usuario
	 * @return Usuario
	 */
	@Transactional(rollbackFor = Throwable.class)
	public Usuario add(Usuario usuario) {
		usuario = setEjieDefault(usuario);
		return this.tableUsuarioDao.add(usuario);
	}
	
	/**
	 * Inserts a single row in the Usuario table.
	 *
	 * @param usuario Usuario2
	 * @return Usuario2
	 */
	@Transactional(rollbackFor = Throwable.class)
	public Usuario2 add(Usuario2 usuario) {
		usuario = setEjieDefault(usuario);
		return this.tableUsuarioDao.add(usuario);
	}

	/**
	 * Updates a single row in the Usuario table.
	 *
	 * @param usuario Usuario
	 * @return Usuario
	 */
	@Transactional(rollbackFor = Throwable.class)
	public Usuario update(Usuario usuario) {
		usuario = setEjieDefault(usuario);
		return this.tableUsuarioDao.update(usuario);
	}

	/**
	 * Updates a single row in the Usuario table.
	 *
	 * @param usuario Usuario2
	 * @return Usuario2
	 */
	@Transactional(rollbackFor = Throwable.class)
	public Usuario2 update(Usuario2 usuario) {
		usuario = setEjieDefault(usuario);
		return this.tableUsuarioDao.update(usuario);
	}

	/**
	 * Finds a single row in the Usuario table.
	 *
	 * @param usuario Usuario
	 * @return Usuario
	 */
	public Usuario find(Usuario usuario) {
		return (Usuario) this.tableUsuarioDao.find(usuario);
	}

	/**
	 * Finds a single row in the Usuario table.
	 *
	 * @param usuario Usuario2
	 * @return Usuario2
	 */
	public Usuario2 find(Usuario2 usuario) {
		return (Usuario2) this.tableUsuarioDao.find(usuario);
	}
	
	/**
	 * Deletes a single row in the Usuario table.
	 *
	 * @param usuario Usuario
	 * @return
	 */
	@Transactional(rollbackFor = Throwable.class)
	public void remove(Usuario usuario) {
		this.tableUsuarioDao.remove(usuario);
	}
	
	/**
	 * Deletes a single row in the Usuario table.
	 *
	 * @param usuario Usuario2
	 * @return
	 */
	@Transactional(rollbackFor = Throwable.class)
	public void remove(Usuario2 usuario) {
		this.tableUsuarioDao.remove(usuario);
	}
	
	/**
	 * Finds a List of rows in the Usuario table.
	 *
	 * @param usuario Usuario
	 * @param pagination Pagination
	 * @return List
	 */
	public List<Usuario> findAll(Usuario usuario, TableRequestDto tableRequestDto) {
		return (List<Usuario>) this.tableUsuarioDao.findAll(usuario, tableRequestDto);
	}
    

	/**
	 * Finds rows in the Usuario table using like.
	 *
	 * @param usuario Usuario
	 * @param pagination Pagination
	 * @param startsWith Boolean
	 * @return List
	 */
	public List<Usuario> findAllLike(Usuario usuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		return (List<Usuario>) this.tableUsuarioDao.findAllLike(usuario, tableRequestDto, startsWith);
	}

	
	/*
	 * OPERACIONES RUP_TABLE
	 */
	
	/**
	 * Deletes multiple rows in the Usuario table.
	 *
	 * @param filterUsuario Usuario
	 * @param tableRequestDto TableRequestDto
	 * @param startsWith Boolean	 
	 */	
	@Transactional(rollbackFor = Throwable.class)
	public void removeMultiple(Usuario filterUsuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		this.tableUsuarioDao.removeMultiple(filterUsuario, tableRequestDto, startsWith);
	}
	
	/**
	 * Deletes multiple rows in the Usuario table.
	 *
	 * @param filterUsuario Usuario2
	 * @param tableRequestDto TableRequestDto
	 * @param startsWith Boolean	 
	 */	
	@Transactional(rollbackFor = Throwable.class)
	public void removeMultiple(Usuario2 filterUsuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		this.tableUsuarioDao.removeMultiple(filterUsuario, tableRequestDto, startsWith);
	}
	
	@Transactional(rollbackFor = Throwable.class)
	public List<Usuario> getMultiple(Usuario filterUsuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		return this.tableUsuarioDao.getMultiple(filterUsuario, tableRequestDto, startsWith);
	}

	@Override
	public Object reorderSelection(Usuario usuario, TableRequestDto tableRequestDto,
			Boolean startsWith) {
		return this.tableUsuarioDao.reorderSelection(usuario, tableRequestDto, startsWith);
	}

	@Override
	public List<TableRowDto<Usuario>> search(Usuario filterParams, Usuario searchParams, TableRequestDto tableRequestDto, Boolean startsWith) {
		return this.tableUsuarioDao.search(filterParams, searchParams, tableRequestDto, startsWith);
	}

	@Override
	public List<TableRowDto<Usuario2>> search(Usuario2 filterParams, Usuario2 searchParams, TableRequestDto tableRequestDto, Boolean startsWith) {
		return this.tableUsuarioDao.search(filterParams, searchParams, tableRequestDto, startsWith);
	}

	@Override
	public TableResourceResponseDto<Usuario> filter(Usuario filterUsuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		List<Usuario> listaUsuario = this.tableUsuarioDao.findAllLike(filterUsuario, tableRequestDto, false);
		Long recordNum = this.tableUsuarioDao.findAllLikeCount(filterUsuario != null ? filterUsuario : new Usuario(), false);
		TableResourceResponseDto<Usuario> usuarioDto = new TableResourceResponseDto<Usuario>(tableRequestDto, recordNum, listaUsuario);
		if (tableRequestDto.getMultiselection().getSelectedIds() != null && !tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			List<TableRowDto<Usuario>> reorderSelection = this.tableUsuarioDao.reorderSelection(filterUsuario, tableRequestDto, startsWith);
			usuarioDto.setReorderedSelection(reorderSelection);
			usuarioDto.addAdditionalParam("reorderedSelection", reorderSelection);
			usuarioDto.addAdditionalParam("selectedAll", tableRequestDto.getMultiselection().getSelectedAll());
		}
		if (tableRequestDto.getSeeker().getSelectedIds() != null) {
			tableRequestDto.setMultiselection(tableRequestDto.getSeeker());
			List<TableRowDto<Usuario>> reorderSeeker = this.tableUsuarioDao.reorderSelection(filterUsuario, tableRequestDto, startsWith);
			usuarioDto.setReorderedSeeker(reorderSeeker);
			usuarioDto.addAdditionalParam("reorderedSeeker", reorderSeeker);
		}
		return usuarioDto; 
	}

	@Override
	public TableResourceResponseDto<Usuario2> filter(Usuario2 filterUsuario, TableRequestDto tableRequestDto, Boolean startsWith) {
		List<Usuario2> listaUsuario = this.tableUsuarioDao.findAllLike(filterUsuario, tableRequestDto, false);
		Long recordNum = this.tableUsuarioDao.findAllLikeCount(filterUsuario != null ? filterUsuario: new Usuario2(), false);
		TableResourceResponseDto<Usuario2> usuarioDto = new TableResourceResponseDto<Usuario2>(tableRequestDto, recordNum, listaUsuario);
		if (tableRequestDto.getMultiselection().getSelectedIds() != null && !tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			List<TableRowDto<Usuario2>> reorderSelection = this.tableUsuarioDao.reorderSelection(filterUsuario, tableRequestDto, startsWith);
			usuarioDto.setReorderedSelection(reorderSelection);
			usuarioDto.addAdditionalParam("reorderedSelection", reorderSelection);
			usuarioDto.addAdditionalParam("selectedAll", tableRequestDto.getMultiselection().getSelectedAll());
		}
		if (tableRequestDto.getSeeker().getSelectedIds() != null){
			tableRequestDto.setMultiselection(tableRequestDto.getSeeker());
			List<TableRowDto<Usuario2>> reorderSeeker = this.tableUsuarioDao.reorderSelection(filterUsuario, tableRequestDto, startsWith);
			usuarioDto.setReorderedSeeker(reorderSeeker);
			usuarioDto.addAdditionalParam("reorderedSeeker", reorderSeeker);
		}
		return usuarioDto; 
	}
	
	/*
	 * UTILIDADES
	 */
	
	/**
	 * Si el campo "ejie" no tiene un valor definido le establece uno por defecto. No se hace en la entidad para evitar que el filtro siempre filtre por el valor por defecto.
	 *
	 * @param usuario Usuario
	 * @return Usuario
	 */
	private Usuario setEjieDefault(Usuario usuario) {
		if (usuario.getEjie() == null) {
			usuario.setEjie("0");
		}
		return usuario;
	}
	
	/**
	 * Si el campo "ejie" no tiene un valor definido le establece uno por defecto. No se hace en la entidad para evitar que el filtro siempre filtre por el valor por defecto.
	 *
	 * @param usuario Usuario2
	 * @return Usuario
	 */
	private Usuario2 setEjieDefault(Usuario2 usuario) {
		if (usuario.getEjie() == null) {
			usuario.setEjie("0");
		}
		return usuario;
	}
	
	/*
	 * EXPORTACIONES DE DATOS
	 */
	
	/**
	 * Devuelve un fichero en el formato deseado que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	public void generateReport(Usuario filterUsuario, String[] columns, String[] columnsName, String fileName, String sheetTitle, ArrayList<?> reportsParams, TableRequestDto tableRequestDto, Locale locale, HttpServletRequest request, HttpServletResponse response) {
		// Accede a la DB para recuperar datos
		List<Usuario> filteredData = getDataForReports(filterUsuario, tableRequestDto);
		String extension = null;
		
		// Obtener idioma
		String language = locale.getLanguage();
		
		// Comprobar si las siguientes variables estan vacias, en caso de estarlo se las asigna un valor generico
		fileName = (fileName != null && !fileName.isEmpty()) ? fileName : "report";
		sheetTitle = (sheetTitle != null && !sheetTitle.isEmpty()) ? sheetTitle : Usuario.class.getSimpleName();
		
		// Obtener el formato de fecha especifico del locale
        SimpleDateFormat formatter = DateTimeManager.getDateTimeFormat(locale);
		
		// Cuando no se definen columnas porque se quieren obtener todas
        if (columns == null) {
        	Field[] fields = Usuario.class.getDeclaredFields();
        	ArrayList<String> tempColumns = new ArrayList<String>();
	        
	        for(int i = 0; i < fields.length; i++) {
	        	try {
	        		String methodName = fields[i].getName();
	        		methodName = methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
    				Usuario.class.getMethod("get" + methodName);
    				tempColumns.add(fields[i].getName());
    			} catch (NoSuchMethodException e) {
    				e.printStackTrace();
    			}
	        	
	        }
	        columns = tempColumns.toArray(new String[0]);
        }
        
        // Si no se definen los nombres de las columnas se dejan las definidas por defecto
        if (columnsName == null) {
        	columnsName = columns;
        }
		
		String servletPath = request.getServletPath();
		String reportType = null;
		if (servletPath.contains("/") && (servletPath.lastIndexOf("/") + 1 != servletPath.length())) {
			reportType = servletPath.substring(servletPath.lastIndexOf("/") + 1, servletPath.length());
		} else {
			reportType = servletPath.substring(0, servletPath.length());
		}
		
		if (reportType.equals("xlsReport")) {
			extension = ".xls";
			generateExcelReport(filteredData, columns, columnsName, fileName, sheetTitle, extension, formatter, response);
		} else if (reportType.equals("xlsxReport")) {
			extension = ".xlsx";
			generateExcelReport(filteredData, columns, columnsName, fileName, sheetTitle, extension, formatter, response);
		} else if (reportType.equals("pdfReport")) {
			extension = ".pdf";
			generatePDFReport(filteredData, columns, columnsName, fileName, response);
		} else if (reportType.equals("odsReport")) {
			extension = ".ods";
			generateODSReport(filteredData, columns, columnsName, fileName, sheetTitle, response);
		} else if (reportType.equals("csvReport")) {
			extension = ".csv";
			generateCSVReport(filteredData, columns, columnsName, fileName, sheetTitle, language, response);
		}
	}
	
	/**
	 * Devuelve un fichero en el formato deseado que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario2
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	public void generateReport(Usuario2 filterUsuario, String[] columns, String[] columnsName, String fileName, String sheetTitle, ArrayList<?> reportsParams, TableRequestDto tableRequestDto, Locale locale, HttpServletRequest request, HttpServletResponse response) {
		// Accede a la DB para recuperar datos
		List<Usuario2> filteredData = getDataForReports(filterUsuario, tableRequestDto);
		String extension = null;
		
		// Obtener idioma
		String language = locale.getLanguage();
		
		// Comprobar si las siguientes variables estan vacias, en caso de estarlo se las asigna un valor generico
		fileName = (fileName != null && !fileName.isEmpty()) ? fileName : "report";
		sheetTitle = (sheetTitle != null && !sheetTitle.isEmpty()) ? sheetTitle : Usuario2.class.getSimpleName();
		
		// Obtener el formato de fecha especifico del locale
        SimpleDateFormat formatter = DateTimeManager.getDateTimeFormat(locale);
		
		// Cuando no se definen columnas porque se quieren obtener todas
        if (columns == null) {
        	Field[] fields = Usuario.class.getDeclaredFields();
        	ArrayList<String> tempColumns = new ArrayList<String>();
	        
	        for(int i = 0; i < fields.length; i++) {
	        	try {
	        		String methodName = fields[i].getName();
	        		methodName = methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
    				Usuario.class.getMethod("get" + methodName);
    				tempColumns.add(fields[i].getName());
    			} catch (NoSuchMethodException e) {
    				e.printStackTrace();
    			}
	        	
	        }
	        columns = tempColumns.toArray(new String[0]);
        }
        
        // Si no se definen los nombres de las columnas se dejan las definidas por defecto
        if (columnsName == null) {
        	columnsName = columns;
        }
		
		String servletPath = request.getServletPath();
		String reportType = null;
		if (servletPath.contains("/") && (servletPath.lastIndexOf("/") + 1 != servletPath.length())) {
			reportType = servletPath.substring(servletPath.lastIndexOf("/") + 1, servletPath.length());
		} else {
			reportType = servletPath.substring(0, servletPath.length());
		}
		
		if (reportType.equals("xlsReport")) {
			extension = ".xls";
			generateExcelReport(filteredData, columns, columnsName, fileName, sheetTitle, extension, formatter, response);
		} else if (reportType.equals("xlsxReport")) {
			extension = ".xlsx";
			generateExcelReport(filteredData, columns, columnsName, fileName, sheetTitle, extension, formatter, response);
		} else if (reportType.equals("pdfReport")) {
			extension = ".pdf";
			generatePDFReport(filteredData, columns, columnsName, fileName, response);
		} else if (reportType.equals("odsReport")) {
			extension = ".ods";
			generateODSReport(filteredData, columns, columnsName, fileName, sheetTitle, response);
		} else if (reportType.equals("csvReport")) {
			extension = ".csv";
			generateCSVReport(filteredData, columns, columnsName, fileName, sheetTitle, language, response);
		}
	}

	/**
	 * Devuelve los datos recuperados de la DB.
	 *
	 * @param filterUsuario Usuario
	 * @param tableRequestDto TableRequestDto
	 */
	public List<Usuario> getDataForReports(Usuario filterUsuario, TableRequestDto tableRequestDto) {
		if (tableRequestDto.getMultiselection().getSelectedAll() && tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			if (filterUsuario != null) {
				return this.tableUsuarioDao.findAllLike(filterUsuario, tableRequestDto, false);
			} else {
				return this.tableUsuarioDao.findAll(new Usuario(), null);
			}
		} else {
			return this.tableUsuarioDao.getMultiple(filterUsuario, tableRequestDto, false);
		}
	}

	/**
	 * Devuelve los datos recuperados de la DB.
	 *
	 * @param filterUsuario Usuario2
	 * @param tableRequestDto TableRequestDto
	 */
	public List<Usuario2> getDataForReports(Usuario2 filterUsuario, TableRequestDto tableRequestDto) {
		if (tableRequestDto.getMultiselection().getSelectedAll() && tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			if (filterUsuario != null) {
				return this.tableUsuarioDao.findAllLike(filterUsuario, tableRequestDto, false);
			} else {
				return this.tableUsuarioDao.findAll(new Usuario2(), null);
			}
		} else {
			return this.tableUsuarioDao.getMultiple(filterUsuario, tableRequestDto, false);
		}
	}
	
	/**
	 * Devuelve un fichero excel que contiene los datos exportados de la tabla.
	 *
	 * @param filteredData List<?>
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param extension String
	 * @param formatter SimpleDateFormat
	 * @param response HttpServletResponse
	 */
	private void generateExcelReport(List<?> filteredData, String[] columns, String[] columnsName, String fileName, String sheetTitle, String extension, SimpleDateFormat formatter, HttpServletResponse response) {
		try {
			// Creacion del Excel
			Workbook workbook = null;
			if (extension == ".xlsx"){
				workbook = new XSSFWorkbook();
				response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
			} else {
				workbook = new HSSFWorkbook();
				response.setContentType("application/vnd.ms-excel");
			}
			
	        response.setHeader("Content-Disposition", "attachment; filename=" + fileName + extension + "");
			
			// Creacion de una hoja y asignacion de su nombre
	        Sheet sheet = workbook.createSheet(sheetTitle);
	        
	        // Se crea una fuente para estilizar las cabeceras
	        Font headerFont = workbook.createFont();
	        headerFont.setBold(true);
	        headerFont.setFontHeightInPoints((short) 12);
	        
	        // Se crea un CellStyle con la fuente
	        CellStyle headerCellStyle = workbook.createCellStyle();
	        headerCellStyle.setAlignment(HorizontalAlignment.CENTER);
	        headerCellStyle.setFont(headerFont);
	        
	        // Inicializar contador de filas
	        int rowNumber = 0;
	        
	        // Se crea la fila para insertar los titulos de las columnas
	        Row row = sheet.createRow(rowNumber++);
	        
	        // Añadir titulos
	        for(int i = 0; i < columnsName.length; i++) {
	        	Cell cell = row.createCell(i);
	            cell.setCellValue(columnsName[i]);
	            cell.setCellStyle(headerCellStyle);
	        }
	        
	        // CreationHelper ayudara a mantener la compatibilidad del DataFormat tanto si se crea un .xls como un .xlsx
	        CreationHelper createHelper = workbook.getCreationHelper();
	        
	        // Se crea un CellStyle para añadir el formateador de fechas
	        CellStyle dateCellStyle = workbook.createCellStyle();
	        dateCellStyle.setDataFormat(createHelper.createDataFormat().getFormat(formatter.toPattern()));
	        
	        // Añadir datos
	        for (Object rowObject : filteredData) {
	        	int cellNumber = 0;
	        	row = sheet.createRow(rowNumber++);
	        	
	        	// Se iteran las columnas y se insertan los datos respetando el orden que tenian las columnas en la tabla
	        	for (String column : columns) {
	        		Cell cellUsuario = row.createCell(cellNumber++);
	        		cellUsuario.setCellValue(getCellValue(column, rowObject));
	        	}
	        }
	        
	        // Se adapta el ancho de las columnas al contenido
	        for(int i = 0; i < columns.length; i++) {
	            sheet.autoSizeColumn(i);
	        }

			// Se añade el fichero excel al response
	        workbook.write(response.getOutputStream());
            workbook.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Devuelve un fichero pdf que contiene los datos exportados de la tabla.
	 *
	 * @param filteredData List<?>
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param response HttpServletResponse
	 */
	private void generatePDFReport(List<?> filteredData, String[] columns, String[] columnsName, String fileName, HttpServletResponse response) {
		try {
			// Se añade el fichero excel al response y se añade el contenido
	        response.setHeader("Content-Disposition", "attachment; filename=" + fileName + ".pdf");
			response.setContentType("application/pdf");
			
			Document document = new Document();
			// Se añade el fichero pdf al response
			PdfWriter.getInstance(document, response.getOutputStream());
			
			document.open();
			 
			PdfPTable table = new PdfPTable(columns.length);

			for (String column : columns) {
				PdfPCell header = new PdfPCell();
		        header.setBorderWidth(2);
		        header.setPhrase(new Phrase(column));
		        table.addCell(header);
        	}
			
			// Añadir datos
	        for (Object rowObject : filteredData) {
	        	// Se iteran las columnas y se insertan los datos respetando el orden que tenian las columnas en la tabla
	        	for (String column : columns) {
	        		table.addCell(getCellValue(column, rowObject));
	        	}
	        }
			
			document.add(table);
			document.close();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Devuelve un fichero ods que contiene los datos exportados de la tabla.
	 *
	 * @param filteredData List<?>
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param response HttpServletResponse
	 */
	private void generateODSReport(List<?> filteredData, String[] columns, String[] columnsName, String fileName, String sheetTitle, HttpServletResponse response) {
		try {
			// Se añade el fichero ods al response y se añade el contenido
	        response.setHeader("Content-Disposition", "attachment; filename=" + fileName + ".ods");
			response.setContentType("application/vnd.oasis.opendocument.spreadsheet");
			
			OdfSpreadsheetDocument ods = OdfSpreadsheetDocument.newSpreadsheetDocument();
			ods.getOrCreateDocumentStyles();
			
			// Hay que eliminar la hoja que se genera por defecto
	        ods.getTableByName("Sheet1").remove();
	        
	        // Hoja nueva
			OdfTable table = OdfTable.newTable(ods, filteredData.size() + 1, columns.length);
			table.setTableName(sheetTitle);
	        
			// Inicializar contador de filas
	        int rowNumber = 0;
			
	        // Cabeceras
			OdfTableRow row = table.getRowByIndex(rowNumber++);
	        for(int i = 0; i < columns.length; i++) {
	        	row.getCellByIndex(i).setStringValue(columns[i]);
	        }

			// Añadir datos
	        for (Object rowObject : filteredData) {
	        	row = table.getRowByIndex(rowNumber++);
				int cellNumber = 0;
				
	        	// Se iteran las columnas y se insertan los datos respetando el orden que tenian las columnas en la tabla
	        	for (String column : columns) {
        			row.getCellByIndex(cellNumber++).setStringValue(getCellValue(column, rowObject));
	        	}
	        }
			
	        // Se añade el fichero ods al response
			ods.save(response.getOutputStream());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Devuelve un fichero csv que contiene los datos exportados de la tabla.
	 *
	 * @param filteredData List<?>
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param language String
	 * @param response HttpServletResponse
	 */
	private void generateCSVReport(List<?> filteredData, String[] columns,String[] columnsName, String fileName, String sheetTitle, String language, HttpServletResponse response) {
		try {
		    // Se añade el fichero excel al response y se añade el contenido
	        response.setHeader("Content-Disposition", "attachment; filename=" + fileName + ".csv");
			response.setContentType("text/csv");
			
			// Separador de campos dependiendo del idioma
			String separator = ";";
			if (language.equals("en")) {
				separator = ",";
			}
			
			// Se añade el fichero csv al response
		    OutputStream out = response.getOutputStream();
		    // Añadir titulos
		    boolean addTitles = true;
			
			// Añadir datos
	        for (Object rowObject : filteredData) {
	        	int cellNumber = 1;
	        	StringBuilder columnsTitles = new StringBuilder();
	        	StringBuilder row = new StringBuilder();
	        	
	        	// Se iteran las columnas y se insertan los datos respetando el orden que tenian las columnas en la tabla
	        	for (String column : columns) {
	        		String cellValue = getCellValue(column, rowObject);
	        		
	        		if (cellNumber < columns.length) {
        				if (addTitles) {
        					columnsTitles.append("\"");
        					columnsTitles.append(column);
        					columnsTitles.append("\"");
        					columnsTitles.append(separator);
        				}
        				row.append("\"");
    					row.append(cellValue);
    					row.append("\"");
    					row.append(separator);
    					cellNumber++;
    				} else {
        				if (addTitles) {
        					columnsTitles.append("\"");
        					columnsTitles.append(column);
        					columnsTitles.append("\"\n");
        				}
        				row.append("\"");
    					row.append(cellValue);
    					row.append("\"\n");
    				}
	        	}
	        	
	        	if (addTitles) {
	        		out.write(columnsTitles.toString().getBytes());
					addTitles = false;
	        	}
	        	out.write(row.toString().getBytes());
	        }
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Obtiene los valores de las celdas.
	 *
	 * @param column String
	 * @param row Object
	 */
	private String getCellValue(String column, Object row) {
		String cellValue = "";
		try {
			cellValue = BeanUtils.getProperty(row, column) != null ? BeanUtils.getProperty(row, column) : "";
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
		}
		
		return cellValue;
	}
}
