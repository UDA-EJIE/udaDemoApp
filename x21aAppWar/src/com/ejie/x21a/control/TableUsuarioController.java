/*
 * Copyright 2012 E.J.I.E., S.A.
 *
 * Licencia con arreglo a la EUPL, Versi√≥n 1.1 exclusivamente (la ¬´Licencia¬ª);
 * Solo podr√° usarse esta obra si se respeta la Licencia.
 * Puede obtenerse una copia de la Licencia en
 *
 * http://ec.europa.eu/idabc/eupl.html
 *
 * Salvo cuando lo exija la legislaci√≥n aplicable o se acuerde por escrito,
 * el programa distribuido con arreglo a la Licencia se distribuye ¬´TAL CUAL¬ª,
 * SIN GARANT√çAS NI CONDICIONES DE NING√öN TIPO, ni expresas ni impl√≠citas.
 * V√©ase la Licencia en el idioma concreto que rige los permisos y limitaciones
 * que establece la Licencia.
 */
package com.ejie.x21a.control;

import java.math.BigDecimal;
import java.text.Normalizer;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.beans.propertyeditors.CustomNumberEditor;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.ServletRequestDataBinder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.multipart.support.ByteArrayMultipartFileEditor;

import com.ejie.x21a.model.Comarca;
import com.ejie.x21a.model.Localidad;
import com.ejie.x21a.model.MultiPk;
import com.ejie.x21a.model.TableOptions;
import com.ejie.x21a.model.Usuario;
import com.ejie.x21a.model.Usuario2;
import com.ejie.x21a.service.TableUsuarioService;
import com.ejie.x21a.util.Constants;
import com.ejie.x38.control.bind.annotation.RequestJsonBody;
import com.ejie.x38.dto.TableRequestDto;
import com.ejie.x38.dto.TableResponseDto;
import com.ejie.x38.dto.TableRowDto;
import com.ejie.x38.generic.model.SelectGeneric;
import com.ejie.x38.rup.table.filter.model.Filter;
import com.ejie.x38.rup.table.filter.service.FilterService;
import com.ejie.x38.util.DateTimeManager;

/**
 * UsuarioServiceImpl generated by UDA 1.0, 26-may-2011 13:46:35.
 * 
 * @author UDA
 */

@Controller
@RequestMapping (value = "/table")
public class TableUsuarioController {
	private static final Logger logger = LoggerFactory.getLogger(TableUsuarioController.class);
	
	@Autowired
	private TableUsuarioService tableUsuarioService;
	
	@Autowired
	private FilterService filterService;
	
	@javax.annotation.Resource
	private ReloadableResourceBundleMessageSource messageSource;
	
	@InitBinder
	protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws ServletException {
		binder.registerCustomEditor(byte[].class,new ByteArrayMultipartFileEditor());
		binder.registerCustomEditor(Date.class, new CustomDateEditor(DateTimeManager.getDateTimeFormat(LocaleContextHolder.getLocale()), true));
		NumberFormat numberFormat = NumberFormat.getInstance(LocaleContextHolder.getLocale());
		binder.registerCustomEditor(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, numberFormat, true));
	}

	/*
	 * OPERACIONES CRUD
	 * 
	 * Metodos correspondientes a las operaciones CRUD (Create, Read, Update, Delete). 
	 * 
	 */
	
	/**
	 * Operaci√≥n CRUD Read. Devuelve el bean correspondiente al identificador
	 * indicado.
	 * 
	 * @param id
	 *            Identificador del objeto que se desea recuperar.
	 * @return Objeto correspondiente al identificador indicado.
	 */
	@GetMapping(value = "/{id}")
	public @ResponseBody Usuario getUsuario(
			@PathVariable String id) {
        Usuario usuario = new Usuario();
		usuario.setId(id);
        usuario = this.tableUsuarioService.find(usuario);
		TableUsuarioController.logger.info("[GET - findBy_PK] : Obtener Usuarios por PK");
        return usuario;
	}
	
	@GetMapping(value = "/{bis}/{id}")
	public @ResponseBody Usuario2 getUsuario2(
			@PathVariable final String bis, 
			@PathVariable String id) {
        Usuario2 usuario = new Usuario2();
		usuario.setId(id);
        usuario = this.tableUsuarioService.find(usuario);
        TableUsuarioController.logger.info("[GET - findBy_PK] : Obtener Usuarios por PK");
		return usuario;
	}
	
	@GetMapping(value = "/configurable")
	public String getFiltroSimple (Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_OPTIONS, new TableOptions());
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		Map<String,String> comboEjie = new LinkedHashMap<String,String>();
		comboEjie.put("", "---");
		comboEjie.put("0", "No");
		comboEjie.put("1", "S√≠");
		model.addAttribute("comboEjie", comboEjie);
		
		return "table";
	}
	
	@GetMapping(value = "/double")
	public String getTableDouble (Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_USUARIO2, new Usuario2());
		model.addAttribute(Constants.MODEL_OPTIONS, new TableOptions());
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		Map<String,String> comboEjie = new LinkedHashMap<String,String>();
		comboEjie.put("", "---");
		comboEjie.put("0", "No");
		comboEjie.put("1", "S√≠");
		model.addAttribute("comboEjie", comboEjie);
		
		return "tableDouble";
	}
	
	@GetMapping(value = "masterDetail")
	public String getSimpleMasterDetail(Model model) {
		model.addAttribute("tituloPagina", messageSource.getMessage("tablaMasterDetail", null, LocaleContextHolder.getLocale()));
		
		Comarca comarca = new Comarca();
		Localidad localidad = new Localidad();
		localidad.setComarca(comarca);
		
		model.addAttribute("comarca", comarca);
		model.addAttribute("localidad", localidad);
		
		return "tableMasterDetail";
	}
	
	@GetMapping(value = "masterDialog")
	public String getMasterDialog(Model model) {
		model.addAttribute("tituloPagina", messageSource.getMessage("tablaMasterDetail", null, LocaleContextHolder.getLocale()));

		Comarca comarca = new Comarca();
		Localidad localidad = new Localidad();
		localidad.setComarca(comarca);
		
		model.addAttribute("comarca", comarca);
		model.addAttribute("localidad", localidad);
		
		return "tableDialogDetail";
	}
	
	@GetMapping(value = "tableDialog")
	public String getTableDialog(Model model) {
		model.addAttribute("tituloPagina", messageSource.getMessage("tabla Dialog", null, LocaleContextHolder.getLocale()));
		model.addAttribute("multiPk", new MultiPk());
		return "tableDialog";
	}
	
	@GetMapping(value = "/tableDialogAjax")
	public String getTableDialogAjax (Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_OPTIONS, new TableOptions());
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		Map<String,String> comboEjie = new LinkedHashMap<String,String>();
		comboEjie.put("", "---");
		comboEjie.put("0", "No");
		comboEjie.put("1", "S√≠");
		model.addAttribute("comboEjie", comboEjie);
		
		return "tableDialogAjax";
	}
	
	@PostMapping(value = "/editForm")
	public String getTableEditForm (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = true) boolean isMultipart,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, isMultipart ? "POST" : actionType);
		model.addAttribute(Constants.MODEL_ISMULTIPART, isMultipart);
		model.addAttribute(Constants.MODEL_ENCTYPE, isMultipart ? Constants.MULTIPART_FORMDATA : Constants.APPLICATION_URLENCODED);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "addMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "add");
			}
		} else {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "editMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "edit");
			}
		}
		
		return "tableEditForm";
	}
	
	@PostMapping(value = "/editFormDouble")
	public String getTableDoubleEditForm (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = true) boolean isMultipart,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO2, new Usuario2());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, isMultipart ? "POST" : actionType);
		model.addAttribute(Constants.MODEL_ISMULTIPART, isMultipart);
		model.addAttribute(Constants.MODEL_ENCTYPE, isMultipart ? Constants.MULTIPART_FORMDATA : Constants.APPLICATION_URLENCODED);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "addMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "add");
			}
		} else {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "editMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "edit");
			}
		}
		
		return "tableDoubleEditForm";
	}
	
	@PostMapping(value = "/editFormMultipart")
	public String getTableEditFormMultipart (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, "POST");
		model.addAttribute(Constants.MODEL_ISMULTIPART, true);
		model.addAttribute(Constants.MODEL_ENCTYPE, Constants.MULTIPART_FORMDATA);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			model.addAttribute(Constants.MODEL_ENDPOINT, "addMultipart");
		} else {
			model.addAttribute(Constants.MODEL_ENDPOINT, "editMultipart");
		}
		
		return "tableEditForm";
	}
	
	@PostMapping(value = "/editFormDoubleMultipart")
	public String getTableDoubleEditFormMultipart (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO2, new Usuario2());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, "POST");
		model.addAttribute(Constants.MODEL_ISMULTIPART, true);
		model.addAttribute(Constants.MODEL_ENCTYPE, Constants.MULTIPART_FORMDATA);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			model.addAttribute(Constants.MODEL_ENDPOINT, "addMultipart");
		} else {
			model.addAttribute(Constants.MODEL_ENDPOINT, "editMultipart");
		}
		
		return "tableDoubleEditForm";
	}
	
	@PostMapping(value = "/inlineEdit")
	public String getTableInlineEdit (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = true) boolean isMultipart,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO, new Usuario());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, isMultipart ? "POST" : actionType);
		model.addAttribute(Constants.MODEL_ISMULTIPART, isMultipart);
		model.addAttribute(Constants.MODEL_ENCTYPE, isMultipart ? Constants.MULTIPART_FORMDATA : Constants.APPLICATION_URLENCODED);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "/table/addMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "/table/add");
			}
		} else {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "/table/editMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "/table/edit");
			}
		}
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		List<String> radioEjie = new ArrayList<String>();
		radioEjie.add("0");
		radioEjie.add("1");
		model.addAttribute("radioEjie", radioEjie);
		
		return "tableInlineEditAuxForm";
	}
	
	@PostMapping(value = "/inlineEditDouble")
	public String getTableDoubleInlineEdit (
			@RequestParam(required = true) String actionType,
			@RequestParam(required = true) boolean isMultipart,
			@RequestParam(required = false) String pkValue,
			Model model) {
		model.addAttribute(Constants.MODEL_USUARIO2, new Usuario2());
		model.addAttribute(Constants.MODEL_ACTIONTYPE, isMultipart ? "POST" : actionType);
		model.addAttribute(Constants.MODEL_ISMULTIPART, isMultipart);
		model.addAttribute(Constants.MODEL_ENCTYPE, isMultipart ? Constants.MULTIPART_FORMDATA : Constants.APPLICATION_URLENCODED);
		
		if (pkValue != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, pkValue);
		}
		
		if (actionType.equals("POST")) {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "addMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "add");
			}
		} else {
			if (isMultipart) {
				model.addAttribute(Constants.MODEL_ENDPOINT, "editMultipart");
			} else {
				model.addAttribute(Constants.MODEL_ENDPOINT, "edit");
			}
		}
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		List<String> radioEjie = new ArrayList<String>();
		radioEjie.add("0");
		radioEjie.add("1");
		model.addAttribute("radioEjie", radioEjie);
		
		return "tableDoubleInlineEditAuxForm";
	}
	
	@GetMapping(value = "/addFromNewWindow")
    public String addFromNewWindow(
    		@RequestParam(value = Constants.IS_DOUBLE, required = false) boolean isDouble,
    		Model model) {
		model.addAttribute(Constants.MODEL_ACTIONTYPE, "POST");
		model.addAttribute(Constants.MODEL_ENCTYPE, Constants.APPLICATION_URLENCODED);
		
		if (isDouble)  {
			Usuario2 usuario = new Usuario2();
			model.addAttribute(Constants.MODEL_USUARIO2, usuario);
			model.addAttribute(Constants.MODEL_ENDPOINT, "2/add");
			model.addAttribute(Constants.IS_DOUBLE, true);
		} else {
			Usuario usuario = new Usuario();
			model.addAttribute(Constants.MODEL_USUARIO, usuario);
			model.addAttribute(Constants.MODEL_ENDPOINT, "add");
			model.addAttribute(Constants.IS_DOUBLE, false);
		}
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		return "tableEditFormNewWindow";
    }
	
	@GetMapping(value = "/editFromNewWindow/{id}")
    public String editFromNewWindow(
    		@PathVariable String id,
    		Model model) {
		model.addAttribute(Constants.MODEL_ACTIONTYPE, "PUT");
		model.addAttribute(Constants.MODEL_ENCTYPE, Constants.APPLICATION_URLENCODED);
		model.addAttribute(Constants.MODEL_USUARIO, this.tableUsuarioService.find(new Usuario(id)));
		model.addAttribute(Constants.MODEL_ENDPOINT, "edit");
		model.addAttribute(Constants.IS_DOUBLE, false);
		
		if (id != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, id);
		}
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		return "tableEditFormNewWindow";
    }
	
	@GetMapping(value = "/editFromNewWindowDouble/{id}")
    public String editFromNewWindowDouble(
    		@PathVariable String id,
    		Model model) {
		model.addAttribute(Constants.MODEL_ACTIONTYPE, "PUT");
		model.addAttribute(Constants.MODEL_ENCTYPE, Constants.APPLICATION_URLENCODED);
		model.addAttribute(Constants.MODEL_USUARIO2, this.tableUsuarioService.find(new Usuario2(id)));
		model.addAttribute(Constants.MODEL_ENDPOINT, "edit");
		model.addAttribute(Constants.IS_DOUBLE, true);
		
		if (id != null) {
			model.addAttribute(Constants.MODEL_PKVALUE, id);
		}
		
		Map<String,String> comboRol = new LinkedHashMap<String,String>();
		comboRol.put("", "---");
		comboRol.put("Administrador", "Administrador");
		comboRol.put("Desarrollador", "Desarrollador");
		comboRol.put("Espectador", "Espectador");
		comboRol.put("Informador", "Informador");
		comboRol.put("Manager", "Manager");
		model.addAttribute("comboRol", comboRol);
		
		return "tableEditFormNewWindow";
    }
	
	@GetMapping(value = "/apellidos")
	public @ResponseBody List<SelectGeneric> getApellidos (
			@RequestParam(value = "q", required = false) String q,
            @RequestParam(value = "c", required = false) Boolean c) {
		List<SelectGeneric> apellidos = new ArrayList<SelectGeneric>();
		if(q != null){
			q = Normalizer.normalize(q, Normalizer.Form.NFD);
			q = q.replaceAll("[^\\p{ASCII}]", "");
			q = q.toUpperCase();
		}else{
			q = "";
		}

		List<String> listaApellidos = new ArrayList<String>();
		listaApellidos.add("Garc√≠a");
		listaApellidos.add("Gonz√°lez");
		listaApellidos.add("Fern√°ndez");
		listaApellidos.add("Rodr√≠guez");
		listaApellidos.add("L√≥pez");
		listaApellidos.add("Mart√≠nez");
		listaApellidos.add("S√°nchez");
		listaApellidos.add("P√©rez");
		listaApellidos.add("G√≥mez");
		listaApellidos.add("Mart√≠n");
		listaApellidos.add("Jim√©nez");
		listaApellidos.add("Ruiz");
		listaApellidos.add("Hern√°ndez");
		listaApellidos.add("D√≠az");
		listaApellidos.add("Moreno");
		listaApellidos.add("√Ålvarez");
		listaApellidos.add("Mu√±oz");
		listaApellidos.add("Romero");
		listaApellidos.add("Alonso");
		listaApellidos.add("Guti√©rrez");
		listaApellidos.add("Navarro");
		listaApellidos.add("Torres");
		listaApellidos.add("Dom√≠nguez");
		listaApellidos.add("V√°zquez");
		listaApellidos.add("Perurena");
		
		for(String str : listaApellidos) {
			String original = str;
			str = Normalizer.normalize(str, Normalizer.Form.NFD);
			str = str.toUpperCase();
			str = str.replaceAll("[^\\p{ASCII}]", "");
			if(q.equals("") || str.indexOf(q) >= 0){
				apellidos.add(new SelectGeneric(original, original));
			}
		}
		
		return apellidos;
	}
	
	@GetMapping(value = "/roles")
	public @ResponseBody List<SelectGeneric> getRoles (
			@RequestParam(value = "q", required = false) String q,
            @RequestParam(value = "c", required = false) Boolean c) {	
		List<SelectGeneric> roles = new ArrayList<SelectGeneric>();
		roles.add(new SelectGeneric("Administrador", "Administrador"));
		roles.add(new SelectGeneric("Desarrollador", "Desarrollador"));
		roles.add(new SelectGeneric("Espectador", "Espectador"));
		roles.add(new SelectGeneric("Informador", "Informador"));
		roles.add(new SelectGeneric("Manager", "Manager"));
		
		return roles;
	}
	
	/**
	 * Devuelve una lista de beans correspondientes a los valores de filtrados
	 * indicados en el objeto pasado como par√É¬°metro.
	 * 
	 * @param usuarioFilter
	 *            Objeto que contiene los par√É¬°metros de filtrado utilizados en
	 *            la b√É¬∫squeda.
	 * @return Lista de objetos correspondientes a la b√É¬∫squeda realizada.
	 */
	@GetMapping(value = "/all")
	public @ResponseBody
	List<Usuario> getAll(@ModelAttribute() Usuario usuarioFilter){
		TableUsuarioController.logger.info("[GET - find_ALL] : Obtener Usuarios por filtro");
		return this.tableUsuarioService.findAllLike(usuarioFilter, null, false);
	}
	
	/**
	 * Devuelve una lista de identificadores.
	 *
	 * @param param String Contiene el valor del campo a buscar.
	 * @param startsWith boolean Define si se usar√° un comod√≠n al inicio.
	 *
	 * @return List<Usuario> Lista de objetos correspondientes a la b√∫squeda realizada.
	 */
	@GetMapping(value = "/allIds")
	public @ResponseBody
	List<Usuario> getAllIds(
			@RequestParam(value = "q", required = true) String param,
            @RequestParam(value = "c", required = true) boolean startsWith) {
		TableUsuarioController.logger.info("[GET - find_ALL_ID] : Obtener CPs de Usuario");
		Usuario usuario = new Usuario(param);
		return this.tableUsuarioService.findAllIds(usuario, startsWith);
	}
	
	/**
	 * Operaci√É¬≥n CRUD Edit. Modificaci√É¬≥n del bean indicado.
	 * 
	 * @param usuario
	 *            Bean que contiene la informaci√É¬≥n a modificar.
	 * @return Bean resultante de la modificaci√É¬≥n.
	 * @throws Exception 
	 */
	@PutMapping(value = "/edit")
	public ResponseEntity<?> edit(@RequestBody Usuario usuario) {
	    try {
	        Usuario usuarioAux = this.tableUsuarioService.update(usuario);

	        return ResponseEntity.ok(usuarioAux);
	    } catch (Exception e) {
	        Map<String, Object> errorBody = new HashMap<>();
	        errorBody.put("rupFeedback", Map.of("message", "Error para pruebas"));

	        return ResponseEntity
	                .status(HttpStatus.NOT_ACCEPTABLE) // üëà 406, tu JS ya lo espera
	                .body(errorBody);
	    }
	}

	
	@PutMapping(value = "/{bis}/edit")
    public @ResponseBody Usuario2 edit2(@PathVariable final String bis,
    		@RequestBody Usuario2 usuario) {
		Usuario2 usuarioAux = this.tableUsuarioService.update(usuario);
		logger.info("Entity correctly updated!");
		return usuarioAux;
    }
	
	@PostMapping(value = "/editMultipart", consumes = { MediaType.MULTIPART_FORM_DATA_VALUE }, produces = "application/json")
	public @ResponseBody Usuario editMultipart(@Validated @ModelAttribute Usuario usuario) {
		logger.info("[POST - editMultipart] : Editar usuario.");
		logger.info("USUARIO :::: {} --- {}\n", usuario.getId(), new Date());

		if (!usuario.getImagenAlumno().isEmpty()) {
			logger.info("IMAGEN :::: {}", usuario.getImagenAlumno().getOriginalFilename());
		}

		Usuario usuarioAux = this.tableUsuarioService.update(usuario);
		logger.info("Entity correctly updated!");

		return usuarioAux;
	}
	
	@PostMapping(value = "/{bis}/editMultipart", consumes = { MediaType.MULTIPART_FORM_DATA_VALUE }, produces = "application/json")
	public @ResponseBody Usuario2 editMultipart2(@Validated @ModelAttribute Usuario2 usuario) {
		logger.info("[POST - editMultipart2] : Editar usuario.");
		logger.info("USUARIO2 :::: {} --- {}\n", usuario.getId(), new Date());

		if (!usuario.getImagenAlumno().isEmpty()) {
			logger.info("IMAGEN :::: {}", usuario.getImagenAlumno().getOriginalFilename());
		}

		Usuario2 usuarioAux = this.tableUsuarioService.update(usuario);
		logger.info("Entity correctly updated!");

		return usuarioAux;
	}

	/**
	 * Operaci√É¬≥n CRUD Create. Creaci√É¬≥n de un nuevo registro a partir del bean
	 * indicado.
	 * 
	 * @param usuario
	 *            Bean que contiene la informaci√É¬≥n con la que se va a crear el
	 *            nuevo registro.
	 * @return Bean resultante del proceso de creaci√É¬≥n.
	 */
	@PostMapping(value = "/add")
	public @ResponseBody Usuario add(@Validated @RequestBody Usuario usuario) {		
		Usuario usuarioAux = this.tableUsuarioService.add(usuario);
        logger.info("Entity correctly inserted!");	
        return usuarioAux;
	}
	
	@PostMapping(value = "/{bis}/add")
	public @ResponseBody Usuario2 add2(
			@PathVariable final String bis, 
			@Validated @RequestBody Usuario2 usuario) {		
		Usuario2 usuarioAux = this.tableUsuarioService.add(usuario);
        logger.info("Entity correctly inserted!");	
        return usuarioAux;
	}
	
	@PostMapping(value = "/addMultipart", consumes = { MediaType.MULTIPART_FORM_DATA_VALUE }, produces = "application/json")
	public @ResponseBody Usuario addMultipart(@Validated @ModelAttribute Usuario usuario) {
		logger.info("[POST - addMultipart] : Crear usuario.");
		logger.info("USUARIO :::: {} --- {}\n", usuario.getId(), new Date());
		
		if (!usuario.getImagenAlumno().isEmpty()) {
			logger.info("IMAGEN :::: {}", usuario.getImagenAlumno().getOriginalFilename());
		}
		
		Usuario usuarioAux = this.tableUsuarioService.add(usuario);
		logger.info("Entity correctly inserted!");
		
		return usuarioAux;
	}
	
	@PostMapping(value = "/{bis}/addMultipart", consumes = { MediaType.MULTIPART_FORM_DATA_VALUE }, produces = "application/json")
	public @ResponseBody Usuario2 addMultipart2(@Validated @ModelAttribute Usuario2 usuario) {
		logger.info("[POST - addMultipart2] : Crear usuario.");
		logger.info("USUARIO2 :::: {} --- {}\n", usuario.getId(), new Date());

		if (!usuario.getImagenAlumno().isEmpty()) {
			logger.info("IMAGEN :::: {}", usuario.getImagenAlumno().getOriginalFilename());
		}

		Usuario2 usuarioAux = this.tableUsuarioService.add(usuario);
		logger.info("Entity correctly inserted!");

		return usuarioAux;
	}

	/**
	 * Operaci√É¬≥n CRUD Delete. Borrado del registro correspondiente al
	 * identificador especificado.
	 * 
	 * @param id
	 *            Identificador del objeto que se desea eliminar.
	 * @return Bean eliminado.
	 */
	@DeleteMapping(value = "/{id}")
	@ResponseStatus(value=HttpStatus.OK)
    public @ResponseBody Usuario remove(@PathVariable String id, HttpServletResponse  response) {
        Usuario usuario = new Usuario();
        usuario.setId(id);
        this.tableUsuarioService.remove(usuario);
        logger.info("Entity correctly deleted!");
        return usuario;
    }

	/**
	 * Operaci√≥n CRUD Delete. Borrado del registro correspondiente al
	 * identificador especificado.
	 * 
	 * @param id
	 *            Identificador del objeto que se desea eliminar.
	 * @return Bean eliminado.
	 */
	@DeleteMapping(value = "/{bis}/{id}")
	@ResponseStatus(value=HttpStatus.OK)
    public @ResponseBody Usuario2 remove2(@PathVariable String id, HttpServletResponse response) {
        Usuario2 usuario = new Usuario2();
        usuario.setId(id);
        this.tableUsuarioService.remove(usuario);
        logger.info("Entity correctly deleted!");
        return usuario;
    }
	
	
	/*
	 * METODOS COMPONENTE RUP_TABLE
	 * 
	 */
	
	/**
	 * Operaci√É¬≥n de filtrado del componente RUP_TABLE.
	 * 
	 * @param filterUsuario Usuario
	 *            Bean que contiene los par√É¬°metros de filtrado a emplear.
	 * @param tableRequestDto TableRequestDto
	 *            Dto que contiene los par√É¬°mtros de configuraci√É¬≥n propios del
	 *            RUP_TABLE a aplicar en el filtrado.
	 * @return Dto que contiene el resultado del filtrado realizado por el
	 *         componente RUP_TABLE.
	 * 
	 */
	//@Json(mixins={@JsonMixin(target=Usuario.class, mixin=UsuarioMixIn.class)})
	@PostMapping(value = "/filter")
	public @ResponseBody TableResponseDto<Usuario> filter(
			@RequestJsonBody(param="filter") Usuario filterUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - table] : Obtener Usuarios");
		return tableUsuarioService.filter(filterUsuario, tableRequestDto, false);
	}

	@PostMapping(value = "/{bis}/filter")
	public @ResponseBody() TableResponseDto<Usuario2> filter2(
			@PathVariable final String bis,
			@RequestJsonBody(param="filter") Usuario2 filterUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - table] : Obtener Usuarios 2");
		return tableUsuarioService.filter(filterUsuario, tableRequestDto, false);
	}
	
	// Obtiene el formulario del multi filtro
	@PostMapping(value = "/multiFilter")
	public String getMultiFilterForm (
			@RequestParam(required = false) String mapping,
			@RequestParam(required = true) String tableID,
			@RequestParam(required = true) String containerClass,
			@RequestParam(required = true) String labelClass,
			@RequestParam(required = true) String defaultContainerClass,
			@RequestParam(required = true) String defaultCheckboxClass,
			Model model) {
		model.addAttribute(Constants.MODEL_FILTER, new Filter());
		model.addAttribute(Constants.MODEL_TABLEID, tableID);
		model.addAttribute("containerClass", containerClass);
		model.addAttribute("labelClass", labelClass);
		model.addAttribute("defaultContainerClass", defaultContainerClass);
		model.addAttribute("defaultCheckboxClass", defaultCheckboxClass);
		
		// Controlar que el mapping siempre se a√±ada al modelo de la manera esperada
		if (mapping == null || mapping.isEmpty()) {
			mapping = "/table/multiFilter";
		} else if (mapping.endsWith("/")) {
			mapping = mapping.substring(0, mapping.length() - 1);
		}
		model.addAttribute("mapping", mapping);
		
		return "multiFilterForm";
	}
	
	// Obtiene el formulario del multi filtro
	@PostMapping(value = "{bis}/multiFilter")
	public String getMultiFilterForm2 (
			@RequestParam(required = false) String mapping,
			@RequestParam(required = true) String tableID,
			@RequestParam(required = true) String containerClass,
			@RequestParam(required = true) String labelClass,
			@RequestParam(required = true) String defaultContainerClass,
			@RequestParam(required = true) String defaultCheckboxClass,
			Model model) {
		model.addAttribute(Constants.MODEL_FILTER, new Filter());
		model.addAttribute(Constants.MODEL_TABLEID, tableID);
		model.addAttribute("containerClass", containerClass);
		model.addAttribute("labelClass", labelClass);
		model.addAttribute("defaultContainerClass", defaultContainerClass);
		model.addAttribute("defaultCheckboxClass", defaultCheckboxClass);
		
		// Controlar que el mapping siempre se a√±ada al modelo de la manera esperada
		if (mapping == null || mapping.isEmpty()) {
			mapping = "/table/multiFilter";
		} else if (mapping.endsWith("/")) {
			mapping = mapping.substring(0, mapping.length() - 1);
		}
		model.addAttribute("mapping", mapping);
		
		return "multiFilterForm";
	}
	
	// A√±ade o actualiza un filtro
	@PostMapping(value = "/multiFilter/add")
	public @ResponseBody Filter filterAdd(@RequestBody Filter filtro){
		TableUsuarioController.logger.info("[POST - table] : add filter");
		return filterService.insert(filtro);
	}
	
	// Elimina un filtro
	@DeleteMapping(value = "/multiFilter/delete")
	public @ResponseBody Filter filterDelete(@RequestBody Filter filtro) {
		TableUsuarioController.logger.info("[DELETE - table] : delete filter");
		return filterService.delete(filtro);
	}
	
	// Obtiene el filtro por defecto
	@GetMapping(value = "/multiFilter/getDefault")
	public @ResponseBody Filter filterGetDefault(
			@RequestParam(value = "selector", required = true) String selector,
			@RequestParam(value = "user", required = true) String user) {
		TableUsuarioController.logger.info("[GET - table] : getDefault filter");
		return filterService.getDefault(selector, user);
	}
	
	// Obtiene los filtros disponibles
	@GetMapping(value = "/multiFilter/getAll")
	public @ResponseBody List<Filter> filterGetAll(
			@RequestParam(value = "q", required = false) String q,
			@RequestParam(value = "c", required = false) Boolean c,
			@RequestParam(value = "selector", required = true) String selector,
			@RequestParam(value = "user", required = true) String user) {
		TableUsuarioController.logger.info("[GET - table] : GetAll filter");
		return filterService.getAllFilters(selector, user);
	}
	
	/**
	 * Operaci√≥n de b√∫squeda del componente RUP_TABLE.
	 * 
	 * @param filterUsuario
	 *            Bean que contiene los par√É¬°metros de filtrado a emplear.
	 * @param searchUsuario
	 *            Bean que contiene los par√É¬°metros de b√É¬∫squeda a emplear.
	 * @param tableRequestDto
	 *            Dto que contiene los par√É¬°mtros de configuraci√É¬≥n propios del
	 *            RUP_TABLE a aplicar en la b√É¬∫squeda.
	 * @return Lista de lineas de la tabla que se corresponden con los registros
	 *         que se ajustan a los par√É¬°metros de b√É¬∫squeda.
	 * 
	 */
	@PostMapping(value = "/search")
	public @ResponseBody List<TableRowDto<Usuario>> search(
			@RequestJsonBody(param="filter") Usuario filterUsuario,
			@RequestJsonBody(param="search") Usuario searchUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto){
		TableUsuarioController.logger.info("[POST - search] : Buscar Usuarios");
		return tableUsuarioService.search(filterUsuario, searchUsuario, tableRequestDto, false);
	}
	
	/**
	 * Operaci√≥n de b√∫squeda del componente RUP_TABLE.
	 * 
	 * @param filterUsuario
	 *            Bean que contiene los par√°metros de filtrado a emplear.
	 * @param searchUsuario
	 *            Bean que contiene los par√°metros de b√∫squeda a emplear.
	 * @param tableRequestDto
	 *            Dto que contiene los par√°mtros de configuraci√≥n propios del
	 *            RUP_TABLE a aplicar en la b√∫squeda.
	 * @return Lista de lineas de la tabla que se corresponden con los registros
	 *         que se ajustan a los par√°metros de b√∫squeda.
	 * 
	 */
	@PostMapping(value = "/{bis}/search")
	public @ResponseBody List<TableRowDto<Usuario2>> search2(
			@RequestJsonBody(param="filter") Usuario2 filterUsuario,
			@RequestJsonBody(param="search") Usuario2 searchUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto){
		TableUsuarioController.logger.info("[POST - search] : Buscar Usuarios");
		return tableUsuarioService.search(filterUsuario, searchUsuario, tableRequestDto, false);
	}
	
	/**
	 * Borrado m√É¬∫ltiple de registros
	 * 
	 * @param filterUsuario Usuario
	 *            Bean que contiene los par√É¬°metros de filtrado a emplear.
	 * @param TableRequestDto
	 *            Dto que contiene los par√É¬°mtros de configuraci√É¬≥n propios del
	 *            RUP_TABLE a aplicar en la b√É¬∫squeda.
	 * @return Lista de los identificadores de los registros eliminados.
	 */
	@PostMapping(value = "/deleteAll")
	@ResponseStatus(value=HttpStatus.OK)
	public @ResponseBody List<String> removeMultiple(
			@RequestJsonBody(param="filter") Usuario filterUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - removeMultiple] : Eliminar multiples usuarios");
		this.tableUsuarioService.removeMultiple(filterUsuario, tableRequestDto, false);
	    TableUsuarioController.logger.info("All entities correctly deleted!");
	    
	    return tableRequestDto.getMultiselection().getSelectedIds();
	}
	
	/**
	 * Borrado m√∫ltiple de registros
	 * 
	 * @param filterUsuario Usuario2
	 *            Bean que contiene los par√°metros de filtrado a emplear.
	 * @param TableRequestDto
	 *            Dto que contiene los par√°mtros de configuraci√≥n propios del
	 *            RUP_TABLE a aplicar en la b√∫squeda.
	 * @return Lista de los identificadores de los registros eliminados.
	 */
	@PostMapping(value = "{bis}/deleteAll")
	@ResponseStatus(value=HttpStatus.OK)
	public @ResponseBody List<String> removeMultiple2(
			@RequestJsonBody(param="filter") Usuario2 filterUsuario,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - removeMultiple] : Eliminar multiples usuarios");
		this.tableUsuarioService.removeMultiple(filterUsuario, tableRequestDto, false);
	    TableUsuarioController.logger.info("All entities correctly deleted!");
	    
	    return tableRequestDto.getMultiselection().getSelectedIds();
	}
	
	/*
	 * EXPORTACIONES DE DATOS
	 */
	
	/**
	 * Devuelve los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 */
	@PostMapping(value = "/clipboardReport")
	public @ResponseBody List<Usuario> getClipboardReport(
			@RequestJsonBody(param = "filter", required = false) Usuario filterUsuario,
			@RequestParam(required = false) String[] columns, 
			@RequestParam(required = false) String[] columnsName,
			@RequestParam(required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - clipboardReport] : Copiar multiples usuarios");
		return this.tableUsuarioService.getDataForReports(filterUsuario, tableRequestDto);
	}
	
	@PostMapping(value = "{bis}/clipboardReport")
	public @ResponseBody List<Usuario2> getClipboardReport2(
			@PathVariable final String bis,
			@RequestJsonBody(param = "filter", required = false) Usuario2 filterUsuario,
			@RequestParam(required = false) String[] columns, 
			@RequestParam(required = false) String[] columnsName,
			@RequestParam(required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto) {
		TableUsuarioController.logger.info("[POST - clipboardReport2] : Copiar multiples usuarios");
		return this.tableUsuarioService.getDataForReports(filterUsuario, tableRequestDto);
	}
	
	/**
	 * Devuelve un fichero excel que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	@PostMapping(value = {"/xlsReport" , "/xlsxReport"}, produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateExcelReport(
			@RequestJsonBody(param = "filter", required = false) Usuario filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName, 
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response) throws ServletException{
		TableUsuarioController.logger.info("[POST - generateExcelReport] : Devuelve un fichero excel");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
    }
	
	@PostMapping(value = {"{bis}/xlsReport" , "{bis}/xlsxReport"}, produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateExcelReport2(
			@PathVariable final String bis,
			@RequestJsonBody(param = "filter", required = false) Usuario2 filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns2, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response) throws ServletException{
		TableUsuarioController.logger.info("[POST - generateExcelReport2] : Devuelve un fichero excel");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
        
        // Corregir nombres de columnas
        ArrayList<String> tempColumns = new ArrayList<String>();
        for (String column : columns2) {
        	String newColumn = column.substring(0, column.length() - 1);
        	tempColumns.add(newColumn);
        }
        String[] columns = tempColumns.toArray(new String[0]);
        
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
    }
	
	/**
	 * Devuelve un fichero pdf que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	@PostMapping(value = "pdfReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generatePDFReport(
			@RequestJsonBody(param = "filter", required = false) Usuario filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generatePDFReport] : Devuelve un fichero pdf");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
	
	@PostMapping(value = "{bis}/pdfReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generatePDFReport2(
			@PathVariable final String bis,
			@RequestJsonBody(param = "filter", required = false) Usuario2 filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns2, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generatePDFReport2] : Devuelve un fichero pdf");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
        
        // Corregir nombres de columnas
        ArrayList<String> tempColumns = new ArrayList<String>();
        for (String column : columns2) {
        	String newColumn = column.substring(0, column.length() - 1);
        	tempColumns.add(newColumn);
        }
        String[] columns = tempColumns.toArray(new String[0]);
        
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
	
	/**
	 * Devuelve un fichero ods que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	@PostMapping(value = "odsReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateODSReport(
			@RequestJsonBody(param = "filter", required = false) Usuario filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generateODSReport] : Devuelve un fichero ods");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
	
	@PostMapping(value = "{bis}/odsReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateODSReport2(
			@PathVariable final String bis,
			@RequestJsonBody(param = "filter", required = false) Usuario2 filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns2, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generateODSReport2] : Devuelve un fichero ods");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
        
        // Corregir nombres de columnas
        ArrayList<String> tempColumns = new ArrayList<String>();
        for (String column : columns2) {
        	String newColumn = column.substring(0, column.length() - 1);
        	tempColumns.add(newColumn);
        }
        String[] columns = tempColumns.toArray(new String[0]);
        	
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
	
	/**
	 * Devuelve un fichero csv que contiene los datos exportados de la tabla.
	 *
	 * @param filterUsuario Usuario
	 * @param columns String[]
	 * @param columnsName String[]
	 * @param fileName String
	 * @param sheetTitle String
	 * @param reportsParams ArrayList<?>
	 * @param tableRequestDto TableRequestDto
	 * @param request HttpServletRequest
	 * @param response HttpServletResponse
	 */
	@PostMapping(value = "csvReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateCSVReport(
			@RequestJsonBody(param = "filter", required = false) Usuario filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generateCSVReport] : Devuelve un fichero csv");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
	
	@PostMapping(value = "{bis}/csvReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	public @ResponseBody void generateCSVReport2(
			@PathVariable final String bis,
			@RequestJsonBody(param = "filter", required = false) Usuario2 filterUsuario, 
			@RequestJsonBody(param = "columns", required = false) String[] columns2, 
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName, 
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto,
			HttpServletRequest request,
			HttpServletResponse response){
		TableUsuarioController.logger.info("[POST - generateCSVReport2] : Devuelve un fichero csv");
		//Idioma
        Locale locale = LocaleContextHolder.getLocale();
        
        // Corregir nombres de columnas
        ArrayList<String> tempColumns = new ArrayList<String>();
        for (String column : columns2) {
        	String newColumn = column.substring(0, column.length() - 1);
        	tempColumns.add(newColumn);
        }
        String[] columns = tempColumns.toArray(new String[0]);
        
		this.tableUsuarioService.generateReport(filterUsuario, columns, columnsName, fileName, sheetTitle, reportsParams, tableRequestDto, locale, request, response);
	}
}
