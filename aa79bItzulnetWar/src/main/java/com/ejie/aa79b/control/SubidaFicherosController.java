package com.ejie.aa79b.control;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.security.GeneralSecurityException;
import java.text.DecimalFormat;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import com.ejie.aa79b.common.Constants;
import com.ejie.aa79b.model.DocumentoTarea;
import com.ejie.aa79b.model.Expediente;
import com.ejie.aa79b.model.Facturas;
import com.ejie.aa79b.model.Fichero;
import com.ejie.aa79b.model.FicheroDocExp;
import com.ejie.aa79b.model.ObservacionesExpediente;
import com.ejie.aa79b.service.FacturasService;
import com.ejie.aa79b.service.ObservacionesExpedienteService;
import com.ejie.aa79b.service.OidsAuxiliarService;
import com.ejie.aa79b.service.SubidaFicherosService;
import com.ejie.aa79b.utils.AESCrypt;
import com.ejie.aa79b.webservices.PIDService;
import com.ejie.x38.control.bind.annotation.RequestJsonBody;

/**
 * SubidaFicherosController generated by UDA, 06-feb-2018 10:13:42.
 *
 * @author UDA
 */

@Controller
@RequestMapping(value = "/ficheros")
public class SubidaFicherosController {

	private static final Logger LOGGER = LoggerFactory.getLogger(SubidaFicherosController.class);

	@Autowired
	private SubidaFicherosService subidaFicherosService;
	@Autowired
	private OidsAuxiliarService oidsAuxiliarService;
	@Autowired
	private ObservacionesExpedienteService observacionesExpedienteService;
	@Autowired
	private FacturasService facturasService;
	@Autowired()
	private PIDService pidService;
	@Autowired()
	private ReloadableResourceBundleMessageSource messageSource;

	private static final String FICH_DESCARGAR = "ficheroParaDescargar";
	private static final String CONTENT_DISPOSITION = "Content-Disposition";
	private static final String ATTACHMENT = "attachment; filename=\"";
	private static final String PRAGMA = "Pragma";
	private static final String CACHE = "cache";
	private static final String EXPIRES = "Expires";
	private static final String CERO = "0";
	private static final String CACHE_CONTROL = "Cache-Control";
	private static final String PRIVATE = "private";
	/*
	 * OPERACIONES CRUD (Create, Read, Update, Delete)
	 *
	 */

	/**
	 * PIF / PID
	 *
	 * @param fichero
	 *            MultipartFile.
	 * @param request
	 *            HttpServletRequest.
	 * @param idioma
	 *            Locale.
	 * @return Fichero Bean Fichero.
	 */
	@RequestMapping(value = "/subidaFichero", method = RequestMethod.POST)
	public @ResponseBody() Fichero subidaFichero(@RequestParam() MultipartFile fichero,
			@RequestParam() String reqEncriptado, @RequestParam(required = false) Integer idBotonUpload) {

		SubidaFicherosController.LOGGER.info("CAMBIO SOLUCION PIF/PID: subidaFichero al PIF");
		Locale locale = LocaleContextHolder.getLocale();

		Fichero bean = new Fichero();
		bean.setEncriptado(Constants.SI);
		String nombreFichero = fichero.getOriginalFilename();
		int elPunto = nombreFichero.lastIndexOf('.');

		BigDecimal limit = new BigDecimal(Constants.TAMANO_FICHERO_MAX_500MB);
		if (Constants.DOS == idBotonUpload) {
			limit = new BigDecimal(Constants.TAMANO_FICHERO_MAX_2MB);
		}

		final DecimalFormat df = new DecimalFormat("#,###.##", new java.text.DecimalFormatSymbols(new Locale("es")));
		Object[] paramT = { ""
				+ (df.format(limit.divide(new BigDecimal(Constants.TAMANO_1MB_EN_BYTES), 2, RoundingMode.CEILING))) };

		if (new BigDecimal(fichero.getSize()).compareTo(limit) == 1) {
			bean.setError(this.messageSource.getMessage("mensaje.fichero.tamanoFich", paramT, locale));
		} else {
			// Comprobar encriptado
				subidaFicheroComprobarEncriptacion(fichero, locale, bean);

				if (Constants.SI.equals(reqEncriptado) && Constants.NO.equals(bean.getEncriptado())) {
					bean.setError(this.messageSource.getMessage("mensaje.fichero.encriptadoRequerido", null, locale));
				} else if (Constants.NO.equals(reqEncriptado) && Constants.SI.equals(bean.getEncriptado())) {
					bean.setError(this.messageSource.getMessage("mensaje.fichero.encriptadoNoPermitido", null, locale));
				} else if (elPunto == -1) {
					// sin extension mensaje.fichero.archivoSinExt
					bean.setError(this.messageSource.getMessage("mensaje.fichero.archivoSinExt", null, locale));
				} else if (bean.getError() == null) {
					procesoSubidaPIF(fichero, locale, bean, nombreFichero, elPunto);
				}
		}
		return bean;
	}

	/**
	 * @param fichero
	 * @param locale
	 * @param bean
	 * @param nombreFichero
	 * @param elPunto
	 */
	private void procesoSubidaPIF(MultipartFile fichero, Locale locale, Fichero bean, String nombreFichero,
			int elPunto) {
		bean.setNombre(nombreFichero);
		bean.setExtension(nombreFichero.substring(elPunto + 1, nombreFichero.length()));
		bean.setTamano(fichero.getSize());
		bean.setContentType(fichero.getContentType());
		try {
			bean.setRutaPif(this.pidService.subidaPif(nombreFichero, fichero.getBytes()));
		} catch (UnsupportedEncodingException e) {
			SubidaFicherosController.LOGGER.info("Error UnsupportedEncodingException: " + e);
			bean.setError(this.messageSource.getMessage("mensaje.fichero.errorCodificacion", null, locale));
		} catch (Exception e) {
			SubidaFicherosController.LOGGER.error("pruebapid: JOSE - subidaFichero Error: ", e);
			bean.setError(this.messageSource.getMessage("mensaje.fichero.errorPIF", null, locale));
		}
	}

	/**
	 * @param fichero
	 *            MultipartFile
	 * @param locale
	 *            Locale
	 * @param bean
	 *            Fichero
	 */
	private void subidaFicheroComprobarEncriptacion(MultipartFile fichero, Locale locale, Fichero bean) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		try {
			AESCrypt aesCrypt = new AESCrypt("222222");
			if (fichero.getSize() > 0) {
				aesCrypt.decrypt(fichero.getSize(), fichero.getInputStream(), baos);
			} else {
				bean.setEncriptado(Constants.NO);
			}
		} catch (GeneralSecurityException e) {
			SubidaFicherosController.LOGGER.info("Error GeneralSecurityException: " + e);
			bean.setError("ERROR GeneralSecurityException " + e.getLocalizedMessage());
		} catch (IOException e) {
			SubidaFicherosController.LOGGER.info("Error IOException: " + e);
			if (e.getLocalizedMessage().contains("password incorrect")) {
				bean.setEncriptado(Constants.SI);
			} else if (e.getLocalizedMessage().contains("header")) {
				bean.setEncriptado(Constants.NO);
			} else {
				bean.setError(this.messageSource.getMessage("mensaje.fichero.errorPIF", null, locale));
			}
		}
	}

	/**
	 * PIF / PID
	 *
	 * @param fichero
	 *            MultipartFile.
	 * @param request
	 *            HttpServletRequest.
	 * @param idioma
	 *            Locale.
	 * @return Fichero Bean Fichero.
	 */

	// CAMBIO SOLUCION PIF/PID
	@RequestMapping(value = "/pasoPIFaPID", method = RequestMethod.POST)
	public @ResponseBody() Fichero pasoPIFaPID(@RequestJsonBody Fichero bean) {
		Locale locale = LocaleContextHolder.getLocale();
		SubidaFicherosController.LOGGER.info("CAMBIO SOLUCION PIF/PID: subidaFichero al PIF");
		try {
			bean.setOid(this.pidService.addDocument(bean.getNombre(), bean.getRutaPif()));
			bean.setRutaPif(Constants.EMPTY);
			this.oidsAuxiliarService.add(bean.getOid());
		} catch (Exception e) {
			bean.setError(this.messageSource.getMessage("mensaje.fichero.errorPID", null, locale) + e);
			SubidaFicherosController.LOGGER.error("ERROR SUBIENDO documento al PID: ", e);
		}
		return bean;

	}

	/**
	 * descarga un doc por su id.
	 *
	 * @param idDoc
	 *            BigDecimal
	 * @param response
	 *            HttpServletResponse
	 */
	@RequestMapping(value = "/descargarDocumento/{tipoDescarga}/{idFichero}", method = RequestMethod.GET)
	public void getDocumento(@PathVariable() int tipoDescarga, @PathVariable() BigDecimal idFichero,
			HttpServletResponse response) {

		Fichero fichero = new Fichero();

		fichero = this.subidaFicherosService.find(tipoDescarga, idFichero);

		abrirDocumentoDescargado(response, fichero);
	}

	/**
	 * Descarga el fichero de observaciones
	 *
	 * @param anyo
	 *            Long
	 * @param numExp
	 *            Integer
	 * @param response
	 *            HttpServletResponse
	 */
	@RequestMapping(value = "/descargarDocumentoObservaciones/{anyo}/{numExp}", method = RequestMethod.GET)
	public void getDocumento(@PathVariable() Long anyo, @PathVariable() Integer numExp, HttpServletResponse response) {

		Expediente expediente = new Expediente();
		expediente.setAnyo(anyo);
		expediente.setNumExp(numExp);
		ObservacionesExpediente observacionesExpediente = this.observacionesExpedienteService
				.observacionesFind(expediente);

		Fichero fichero = new Fichero();
		fichero.setNombre(observacionesExpediente.getNombre());
		fichero.setOid(observacionesExpediente.getOidFichero());
		fichero.setContentType(observacionesExpediente.getContentType());
		fichero.setTamano(observacionesExpediente.getTamano());

		abrirDocumentoDescargado(response, fichero);
	}

	/**
	 * Descarga el fichero de la factura
	 *
	 * @param refLiquidacion
	 *            String
	 * @param response
	 *            HttpServletResponse
	 */
	@RequestMapping(value = "/descargarDocumentoFactura/{refLiquidacion}", method = RequestMethod.GET)
	public void getDocumento(@PathVariable() String refLiquidacion, HttpServletResponse response) {

		Facturas facturasFilter = new Facturas();

		facturasFilter.setIdLiquidacion(refLiquidacion);
		Fichero documentoFactura = this.facturasService.getDocumentoFactura(facturasFilter);

		Fichero fichero = new Fichero();
		fichero.setNombre(documentoFactura.getNombre());
		fichero.setOid(documentoFactura.getOid());
		fichero.setContentType("application/rtf");
		abrirDocumentoFactura(response, fichero);
	}

	/**
	 *
	 * @param fichero
	 * @param request
	 * @param response
	 */
	@RequestMapping(value = "/descargarDocumentoConOid", method = RequestMethod.POST)
	@ResponseBody()
	public void descargarDocumentoConOid(@RequestJsonBody() DocumentoTarea documentoTarea, HttpServletRequest request) {

		request.getSession().setAttribute(FICH_DESCARGAR, documentoTarea);
	}

	/**
	 *
	 * @param response
	 * @param fichero
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/abrirDocumentoDeSesion", method = RequestMethod.GET)
	@ResponseBody()
	private void abrirDocumentoDeSesion(HttpServletRequest request, HttpServletResponse response, Locale locale)
			throws IOException {
		DocumentoTarea documentoTarea = (DocumentoTarea) request.getSession().getAttribute(FICH_DESCARGAR);
		request.getSession().removeAttribute(FICH_DESCARGAR);

		if (documentoTarea.getDocumentoOriginal() != null
				&& !documentoTarea.getDocumentoOriginal().getFicheros().isEmpty()
				&& documentoTarea.getDocumentoOriginal().getFicheros().size() > Constants.UNO) {
			this.generarZipDocumentosTarea(documentoTarea, response);

		} else {
			FicheroDocExp ficheroDocExp = documentoTarea.getDocumentoOriginal().getFicheros().get(Constants.CERO);
			Fichero fichero = this.parsearFicheroDocExpAFichero(ficheroDocExp);
			this.abrirDocumentoDescargado(response, fichero);
		}
	}

	/**
	 * Descarga el fichero al response
	 *
	 * @param response
	 *            HttpServletResponse
	 * @param fichero
	 *            Fichero
	 */
	private void abrirDocumentoDescargado(HttpServletResponse response, Fichero fichero) {
		// Se abre el documento
		response.setContentType(fichero.getContentType());
		response.setHeader(CONTENT_DISPOSITION, ATTACHMENT + fichero.getNombre() + "\"");
		response.setHeader(PRAGMA, CACHE);
		response.setHeader(EXPIRES, CERO);
		response.setHeader(CACHE_CONTROL, PRIVATE);

		if (StringUtils.isNotBlank(fichero.getOid())) {
			try {
				InputStream targetStream = this.pidService.getDocumentInput(fichero.getOid());

				ByteArrayOutputStream baos = new ByteArrayOutputStream(
						new BigDecimal(fichero.getTamano()).intValueExact());

				byte[] outputByte = getNewByte();

				int resto = new BigDecimal(fichero.getTamano()).intValueExact() % 4096;

				while (targetStream.read(outputByte, 0, 4096) == 4096) {
					baos.write(outputByte, 0, 4096);
				}
				if (resto != Constants.CERO) {
					baos.write(outputByte, 0, resto);
				}
				targetStream.close();

				response.setContentLength(baos.size());
				OutputStream os;
				os = response.getOutputStream();
				baos.writeTo(os);
				baos.close();
				os.flush();
				os.close();
			} catch (Exception e) {
				SubidaFicherosController.LOGGER.error("ERROR descargando documento del PID: ", e);
			}
		}
	}
	private void abrirDocumentoFactura(HttpServletResponse response, Fichero fichero) {
		response.setContentType(fichero.getContentType());
		response.setHeader(CONTENT_DISPOSITION, ATTACHMENT + fichero.getNombre() + "\"");
		response.setHeader(PRAGMA, CACHE);
		response.setHeader(EXPIRES, CERO);
		response.setHeader(CACHE_CONTROL, PRIVATE);
		if (StringUtils.isNotBlank(fichero.getOid())) {
			try {
				InputStream is = this.pidService.getDocumentInput(fichero.getOid());

				IOUtils.copy(is, response.getOutputStream());
				response.flushBuffer();
			} catch (IOException ioe) {
				SubidaFicherosController.LOGGER.error("ERROR descargando documento del PID (abrirDocumentoFactura): ioe ", ioe);
			} catch (Exception e) {
				SubidaFicherosController.LOGGER.error("ERROR descargando documento del PID (abrirDocumentoFactura): excp generica - ", e);
			}
		}

	}

	public static ZipEntry getZipEntryInstance(String filename, int num) {
		int elPunto = filename.lastIndexOf(".");
		return new ZipEntry(
				filename.substring(0, elPunto) + "-" + num + filename.substring(elPunto, filename.length()));
	}

	/**
	 * @param zos
	 * @param documento
	 * @param outputByte
	 * @throws IOException
	 */
	private void anadirDocZip(final ZipOutputStream zos, InputStream documento, byte[] outputByte,
			FicheroDocExp fichero) throws IOException {

		int resto = new BigDecimal(fichero.getTamano()).intValueExact() % 4096;
		while (documento.read(outputByte, 0, 4096) == 4096) {
			zos.write(outputByte, 0, 4096);
		}
		if (resto != Constants.CERO) {
			zos.write(outputByte, 0, resto);
		}
	}

	private Fichero parsearFicheroDocExpAFichero(FicheroDocExp ficheroDocExp) {
		Fichero fichero = new Fichero();
		fichero.setContentType(ficheroDocExp.getContentType());
		fichero.setOid(ficheroDocExp.getOid());
		fichero.setNombre(ficheroDocExp.getNombre());
		fichero.setTamano(ficheroDocExp.getTamano());
		return fichero;

	}

	private void generarZipDocumentosTarea(DocumentoTarea documentoTarea, HttpServletResponse response)
			throws IOException {
		Locale locale = LocaleContextHolder.getLocale();
		final ByteArrayOutputStream baos = new ByteArrayOutputStream();
		final ZipOutputStream zos = new ZipOutputStream(baos);
		zos.setLevel(ZipOutputStream.DEFLATED);

		ZipEntry entry = null;
		InputStream documento = null;
		byte[] outputByte = getNewByte();
		int x = 0;
		for (FicheroDocExp fichero : documentoTarea.getDocumentoOriginal().getFicheros()) {
			// Se crea una nueva entrada con el nombre del archivo
			x++;
			entry = getZipEntryInstance(fichero.getNombre(), x);
			try {
				documento = null;
				outputByte = getNewByte();
				documento = this.pidService.getDocumentInput(fichero.getOid());
				zos.putNextEntry(entry);
				// Se escriben los bytes (input = byte[])
				anadirDocZip(zos, documento, outputByte, fichero);
				documento.close();
				zos.closeEntry();
			} catch (Exception e) {
				SubidaFicherosController.LOGGER.error("generarZipDocumentosExp ", e);
			}
		}
		try {
			zos.close();
			documento.close();
		} catch (IOException ioe) {
			SubidaFicherosController.LOGGER.error("generarZipDocumentosExp ", ioe);
		}

		final String message = this.messageSource.getMessage("label.nombreDocTareasZIPgenerado", null, locale);
		StringBuilder nombreZIP = new StringBuilder();
		nombreZIP.append(message);
		nombreZIP.append(documentoTarea.getIdTarea()).append(Constants.PUNTO).append(Constants.ZIP.toLowerCase());

		response.setContentType("application/zip");
		response.setHeader(CONTENT_DISPOSITION, ATTACHMENT + nombreZIP + "\"");
		response.setHeader(PRAGMA, CACHE);
		response.setHeader(EXPIRES, CERO);
		response.setHeader(CACHE_CONTROL, PRIVATE);
		try {
			OutputStream out = response.getOutputStream();
			baos.writeTo(out);
			out.close();
			baos.close();
			response.flushBuffer();
		} catch (Exception e) {
			SubidaFicherosController.LOGGER.error("ERROR descargando documento ZIP: ", e);
		}
	}

	private byte[] getNewByte() {
		return new byte[4096];
	}
}