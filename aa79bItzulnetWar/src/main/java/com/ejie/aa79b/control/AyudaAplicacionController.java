package com.ejie.aa79b.control;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.sql.Clob;
import java.sql.SQLException;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import com.ejie.aa79b.model.AyudaAplicacion;
import com.ejie.aa79b.service.AyudaAplicacionService;
import com.ejie.aa79b.utils.Base64ImageProvider;
import com.ejie.x38.control.bind.annotation.RequestJsonBody;
import com.ejie.x38.dto.JQGridRequestDto;
import com.ejie.x38.dto.JQGridResponseDto;
import com.ejie.x38.dto.TableRowDto;
import com.ejie.x38.json.JSONArray;
import com.ejie.x38.json.JSONObject;
import com.ejie.x38.util.DateTimeManager;
import com.itextpdf.text.BadElementException;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.PageSize;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfDestination;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.PdfPageEventHelper;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.draw.DottedLineSeparator;
import com.itextpdf.tool.xml.Tag;
import com.itextpdf.tool.xml.WorkerContext;
import com.itextpdf.tool.xml.XMLWorker;
import com.itextpdf.tool.xml.XMLWorkerHelper;
import com.itextpdf.tool.xml.html.Span;
import com.itextpdf.tool.xml.html.TagProcessorFactory;
import com.itextpdf.tool.xml.html.Tags;
import com.itextpdf.tool.xml.parser.XMLParser;
import com.itextpdf.tool.xml.pipeline.css.CSSResolver;
import com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline;
import com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline;
import com.itextpdf.tool.xml.pipeline.html.HtmlPipeline;
import com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext;

/**
 * AyudaAplicacionController generated by UDA, 16-nov-2017 14:42:26.
 * 
 * @author UDA
 */

@Controller
@RequestMapping(value = "/administracion/ayudaaplicacion")

public class AyudaAplicacionController {

	private static final Logger LOGGER = LoggerFactory.getLogger(AyudaAplicacionController.class);

	@Autowired
	private AyudaAplicacionService ayudaAplicacionService;

	@Autowired()
	private ReloadableResourceBundleMessageSource messageSource;

	private static final String DATA = "data";
	private static final String TITLE = "title";
	private static final String ID = "id";
	private static final String REL = "rel";
	private static final String MENU = "menu";
	private static final String ATTR = "attr";
	private static final String STATE = "state";
	private static final String OPEN = "open";
	private static final String CHILDREN = "children";
	private static final String ORDEN = "orden";
	private static final String LEVEL = "level";

	/*
	 * OPERACIONES CRUD (Create, Read, Update, Delete)
	 * 
	 */

	/**
	 * Operacion CRUD Read. Devuelve el bean correspondiente al identificador
	 * indicado.
	 * 
	 * @param idAyuda
	 *            Long
	 * @return AyudaAplicacion Objeto correspondiente al identificador indicado.
	 */
	@RequestMapping(value = "/{idAyuda}", method = RequestMethod.GET)
	public @ResponseBody AyudaAplicacion get(@PathVariable Long idAyuda) {
		AyudaAplicacion ayudaAplicacion = new AyudaAplicacion();
		ayudaAplicacion.setIdAyuda(idAyuda);
		ayudaAplicacion = this.ayudaAplicacionService.find(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[GET - findBy_PK] : Obtener AyudaAplicacion por PK");
		return ayudaAplicacion;
	}

	/**
	 * Devuelve una lista de beans correspondientes a los valores de filtrados
	 * indicados en el objeto pasado como parametro.
	 *
	 * @param filterAyudaAplicacion
	 *            AyudaAplicacion Objeto que contiene los parametros de filtrado
	 *            utilizados en la busqueda.
	 * @return List<AyudaAplicacion> Lista de objetos correspondientes a la
	 *         busqueda realizada.
	 */
	@RequestMapping(method = RequestMethod.GET)
	public @ResponseBody List<AyudaAplicacion> getAll(@ModelAttribute AyudaAplicacion filterAyudaAplicacion) {
		AyudaAplicacionController.LOGGER.info("[GET - find_ALL] : Obtener AyudaAplicacion por filtro");
		return this.ayudaAplicacionService.findAll(filterAyudaAplicacion, null);
	}

	/**
	 * Operacion CRUD Edit. Modificacion del bean indicado.
	 *
	 * @param ayudaAplicacion
	 *            AyudaAplicacion Bean que contiene la informacion a modificar.
	 * @return AyudaAplicacion Bean resultante de la modificacion.
	 */
	@RequestMapping(method = RequestMethod.PUT)
	public @ResponseBody AyudaAplicacion edit(@RequestBody AyudaAplicacion ayudaAplicacion) {
		AyudaAplicacion ayudaAplicacionAux = this.ayudaAplicacionService.update(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[PUT] : AyudaAplicacion actualizado correctamente");
		return ayudaAplicacionAux;
	}

	/**
	 * Operacion CRUD Create. Creacion de un nuevo registro a partir del bean
	 * indicado.
	 *
	 * @param ayudaAplicacion
	 *            AyudaAplicacion Bean que contiene la informacion con la que se
	 *            va a crear el nuevo registro.
	 * @return AyudaAplicacion Bean resultante del proceso de creacion.
	 */
	@RequestMapping(method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion add(@RequestBody AyudaAplicacion ayudaAplicacion) {
		AyudaAplicacion ayudaAplicacionAux = this.ayudaAplicacionService.add(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[POST] : AyudaAplicacion insertado correctamente");
		return ayudaAplicacionAux;
	}

	/**
	 * Operacion CRUD Delete. Borrado del registro correspondiente al
	 * identificador especificado.
	 *
	 * @param idAyuda
	 *            Long Identificador del objeto que se desea eliminar.
	 * @return AyudaAplicacion Bean eliminado.
	 */
	@RequestMapping(value = "/{idAyuda}", method = RequestMethod.DELETE)
	@ResponseStatus(value = HttpStatus.OK)
	public @ResponseBody AyudaAplicacion remove(@PathVariable Long idAyuda) {
		AyudaAplicacion ayudaAplicacion = new AyudaAplicacion();
		ayudaAplicacion.setIdAyuda(idAyuda);
		this.ayudaAplicacionService.remove(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[DELETE] : AyudaAplicacion borrado correctamente");
		return ayudaAplicacion;
	}

	/*
	 * METODOS COMPONENTE RUP_TABLE
	 * 
	 */

	/**
	 * Metodo de presentacion del RUP_TABLE.
	 * 
	 * @param model
	 *            Model
	 * @return String
	 */
	@RequestMapping(value = "/maint", method = RequestMethod.GET)
	public String getFormEdit() {
		AyudaAplicacionController.LOGGER.info("[GET - View] : ayudaaplicacion");
		return "ayudaaplicacion";
	}

	/**
	 * Operacion de filtrado del componente RUP_TABLE.
	 * 
	 * @param filterAyudaAplicacion
	 *            AyudaAplicacion Bean que contiene los parametros de filtrado a
	 *            emplear.
	 * @param jqGridRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en el filtrado.
	 * @return JQGridResponseDto<AyudaAplicacion> Dto que contiene el resultado
	 *         del filtrado realizado por el componente RUP_TABLE.
	 */
	@RequestMapping(value = "/filter", method = RequestMethod.POST)
	public @ResponseBody JQGridResponseDto<AyudaAplicacion> filter(
			@RequestJsonBody(param = "filter") AyudaAplicacion filterAyudaAplicacion,
			@RequestJsonBody JQGridRequestDto jqGridRequestDto) {
		AyudaAplicacionController.LOGGER.info("[POST - filter] : Obtener AyudaAplicacions");
		return this.ayudaAplicacionService.filter(filterAyudaAplicacion, jqGridRequestDto, false);
	}

	/**
	 * Operacion de busqueda del componente RUP_TABLE.
	 * 
	 * @param filterAyudaAplicacion
	 *            AyudaAplicacion Bean que contiene los parametros de filtrado a
	 *            emplear.
	 * @param searchAyudaAplicacion
	 *            AyudaAplicacion Bean que contiene los parametros de busqueda a
	 *            emplear.
	 * @param jqGridRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en la búsqueda.
	 * @return TableRowDto<AyudaAplicacion> Dto que contiene el resultado de la
	 *         busqueda realizada por el componente RUP_TABLE.
	 */
	@RequestMapping(value = "/search", method = RequestMethod.POST)
	public @ResponseBody List<TableRowDto<AyudaAplicacion>> search(
			@RequestJsonBody(param = "filter") AyudaAplicacion filterAyudaAplicacion,
			@RequestJsonBody(param = "search") AyudaAplicacion searchAyudaAplicacion,
			@RequestJsonBody JQGridRequestDto jqGridRequestDto) {
		AyudaAplicacionController.LOGGER.info("[POST - search] : Buscar AyudaAplicacions");
		return this.ayudaAplicacionService.search(filterAyudaAplicacion, searchAyudaAplicacion, jqGridRequestDto,
				false);
	}

	/**
	 * Borrado multiple de registros
	 * 
	 * @param filterAyudaAplicacion
	 *            AyudaAplicacion Bean que contiene los parametros de filtrado a
	 *            emplear.
	 * @param jqGridRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en la busqueda.
	 * @return List<String> Lista de los identificadores de los registros
	 *         eliminados.
	 * 
	 */
	@RequestMapping(value = "/deleteAll", method = RequestMethod.POST)
	@ResponseStatus(value = HttpStatus.OK)
	public @ResponseBody List<String> removeMultiple(
			@RequestJsonBody(param = "filter") AyudaAplicacion filterAyudaAplicacion,
			@RequestJsonBody JQGridRequestDto jqGridRequestDto) {
		AyudaAplicacionController.LOGGER
				.info("[POST - search] : [POST - removeMultiple] : Eliminar multiples AyudaAplicacions");
		this.ayudaAplicacionService.removeMultiple(filterAyudaAplicacion, jqGridRequestDto, false);
		AyudaAplicacionController.LOGGER.info("All entities correctly deleted!");

		return jqGridRequestDto.getMultiselection().getSelectedIds();
	}

	/**
	 * Devuelve el árbol de ayudas
	 * 
	 * @param model
	 * @param response
	 * @return Object, objeto json con el árbol de ayudas
	 */
	@RequestMapping(value = "ajaxTree", method = RequestMethod.GET)
	public Object getTreeAjax(HttpServletResponse response) {

		List<AyudaAplicacion> listAyudasAplicacion = this.ayudaAplicacionService.findAll(null);

		JSONArray root = new JSONArray();

		StringBuilder sb = new StringBuilder();
		Locale locale = LocaleContextHolder.getLocale();

		sb.append("{");
		sb.append(DATA);
		sb.append(": {");
		sb.append(TITLE);
		sb.append(": ");
		sb.append(this.messageSource.getMessage("label.ayuda", null, locale));
		sb.append("}, ");
		sb.append(ATTR);
		sb.append(": {");
		sb.append(ID);
		sb.append(": '0', ");
		sb.append(REL);
		sb.append(": ");
		sb.append(MENU);
		sb.append(", ");
		sb.append(ORDEN);
		sb.append(": '0'");
		sb.append(", ");
		sb.append(LEVEL);
		sb.append(": '0'");
		sb.append("}");
		if (!listAyudasAplicacion.isEmpty()) {
			sb.append(", ");
			sb.append(STATE);
			sb.append(": ");
			sb.append(OPEN);
		}
		sb.append("}");

		JSONObject raiz = new JSONObject(sb.toString());

		JSONObject padre = new JSONObject();
		JSONObject hijoNivel1 = new JSONObject();
		JSONObject hijoNivel2;
		JSONArray listaPadres = new JSONArray();
		JSONArray listaHijosNivel1 = new JSONArray();
		JSONArray listaHijosNivel2 = new JSONArray();

		for (AyudaAplicacion ayudaAplicacion : listAyudasAplicacion) {

			if (ayudaAplicacion.getIdAyudaPadre() == 0) {
				if (listaHijosNivel2.length() > 0) {
					this.asignarHijos(hijoNivel1, listaHijosNivel2);
				}
				if (listaHijosNivel1.length() > 0) {
					this.asignarHijos(padre, listaHijosNivel1);
					listaPadres.put(padre);
				} else {
					listaPadres.put(padre);
				}
				// Inicialización de los objetos
				padre = new JSONObject();
				listaHijosNivel1 = new JSONArray();
				listaHijosNivel2 = new JSONArray();

				// Set object
				this.asignarDatosAyudaAplicacion(padre, ayudaAplicacion);
			} else if (ayudaAplicacion.getLevel() == 2) {
				if (listaHijosNivel2.length() > 0) {
					this.asignarHijos(hijoNivel1, listaHijosNivel2);
				}
				listaHijosNivel2 = new JSONArray();
				hijoNivel1 = new JSONObject();

				this.asignarDatosAyudaAplicacion(hijoNivel1, ayudaAplicacion);

				listaHijosNivel1.put(hijoNivel1);
			} else {
				hijoNivel2 = new JSONObject();

				this.asignarDatosAyudaAplicacion(hijoNivel2, ayudaAplicacion);

				listaHijosNivel2.put(hijoNivel2);
			}

		}

		this.getUltimoPadre(padre, hijoNivel1, listaPadres, listaHijosNivel1, listaHijosNivel2);

		raiz.put(CHILDREN, listaPadres);

		root.put(raiz);

		response.setContentType("text/javascript;charset=UTF-8");
		response.setHeader("Cache-Control", "no-cache");
		response.setHeader("Expires", DateTimeManager.getHttpExpiredDate());
		response.setStatus(HttpServletResponse.SC_OK);
		try {
			response.getWriter().write(root.toString());
		} catch (IOException e) {
			AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
		}

		return null;
	}

	/**
	 * @param padre
	 * @param hijoNivel1
	 * @param listaPadres
	 * @param listaHijosNivel1
	 * @param listaHijosNivel2
	 */
	private void getUltimoPadre(JSONObject padre, JSONObject hijoNivel1, JSONArray listaPadres,
			JSONArray listaHijosNivel1, JSONArray listaHijosNivel2) {
		if (padre.length() != 0) {
			if (listaHijosNivel2.length() > 0) {
				this.asignarHijos(hijoNivel1, listaHijosNivel2);
			}
			if (listaHijosNivel1.length() > 0) {
				this.asignarHijos(padre, listaHijosNivel1);
			}
			listaPadres.put(padre);
		}
	}

	/**
	 * Se asigna la lista de hijos correspondientes a un padre
	 * 
	 * @param jsonObject
	 * @param jsonArray
	 */
	private void asignarHijos(JSONObject jsonObject, JSONArray jsonArray) {
		jsonObject.put(CHILDREN, jsonArray);
		jsonObject.put(STATE, OPEN);
	}

	/**
	 * Asigna los datos de ayuda de la aplicación a un objeto JSON
	 * 
	 * @param jsonObject
	 * @param ayudaAplicacion
	 */
	private void asignarDatosAyudaAplicacion(JSONObject jsonObject, AyudaAplicacion ayudaAplicacion) {
		JSONObject data;
		JSONObject attr;
		data = new JSONObject();
		data.put(TITLE, ayudaAplicacion.getTitulo());
		jsonObject.put(DATA, data);
		attr = new JSONObject();
		attr.put(ID, ayudaAplicacion.getIdAyuda());
		attr.put(REL, MENU);
		attr.put(ORDEN, ayudaAplicacion.getOrden());
		attr.put(LEVEL, ayudaAplicacion.getLevel());
		jsonObject.put(ATTR, attr);
	}

	/**
	 * Operacion CRUD Create. Creacion de un nuevo registro a partir del bean
	 * indicado.
	 *
	 * @param ayudaAplicacion
	 *            AyudaAplicacion Bean que contiene la informacion a modificar.
	 * @return AyudaAplicacion Bean resultante del proceso de creacion.
	 * @throws SQLException
	 */
	@RequestMapping(value = "addElement", method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion addElement(@RequestJsonBody AyudaAplicacion ayudaAplicacion)
			throws SQLException {

		ayudaAplicacion.setIdAyudaPadre(ayudaAplicacion.getIdAyudaPadre());
		ayudaAplicacion.setTitulo(ayudaAplicacion.getTitulo());

		AyudaAplicacion ayudaAplicacionAux = this.ayudaAplicacionService.add(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[POST - addElement] : AyudaAplicacion insertado correctamente");
		return ayudaAplicacionAux;

	}

	/**
	 * Operacion CRUD Edit. Modificacion del bean indicado.
	 *
	 * @param ayudaAplicacion
	 *            AyudaAplicacion Bean que contiene la informacion a modificar.
	 * @return AyudaAplicacion Bean resultante de la modificacion.
	 */
	@RequestMapping(value = "updateElement", method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion updateElement(@RequestJsonBody AyudaAplicacion ayudaAplicacion) {
		AyudaAplicacion ayudaAplicacionAux = this.ayudaAplicacionService.update(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[POST - updateElement] : AyudaAplicacion actualizado correctamente");
		return ayudaAplicacionAux;
	}

	/**
	 * Operacion CRUD Edit. Modificacion del bean indicado.
	 *
	 * @param ayudaAplicacion
	 *            AyudaAplicacion Bean que contiene la informacion a modificar.
	 * @return AyudaAplicacion Bean resultante de la modificacion.
	 */
	@RequestMapping(value = "renameElement", method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion renameElement(@RequestJsonBody AyudaAplicacion ayudaAplicacion) {
		AyudaAplicacion ayudaAplicacionAux = this.ayudaAplicacionService.rename(ayudaAplicacion);
		AyudaAplicacionController.LOGGER.info("[POST - updateElement] : AyudaAplicacion actualizado correctamente");
		return ayudaAplicacionAux;
	}

	/**
	 * Operacion CRUD Delete. Borrado del registro correspondiente al
	 * identificador especificado.
	 *
	 * @param idAyuda
	 *            Long Identificador del objeto que se desea eliminar.
	 * @return AyudaAplicacion Bean eliminado.
	 */
	@RequestMapping(value = "removeElement", method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion removeElement(@RequestJsonBody Long idAyuda) throws SQLException {
		AyudaAplicacion filterAyudaAplicacion = new AyudaAplicacion();
		filterAyudaAplicacion.setIdAyudaPadre(idAyuda);

		List<AyudaAplicacion> listAyudasAplicacion = this.ayudaAplicacionService.findAll(filterAyudaAplicacion);

		for (AyudaAplicacion ayudaAplicacion : listAyudasAplicacion) {

			this.ayudaAplicacionService.remove(ayudaAplicacion);

		}

		filterAyudaAplicacion = new AyudaAplicacion();
		filterAyudaAplicacion.setIdAyuda(idAyuda);

		this.ayudaAplicacionService.remove(filterAyudaAplicacion);

		AyudaAplicacionController.LOGGER.info("[DELETE - removeElement] : AyudaAplicacion borrado correctamente");
		return filterAyudaAplicacion;
	}

	/**
	 * Operacion CRUD Read. Devuelve el contenido correspondiente al
	 * identificador indicado.
	 * 
	 * @param idAyuda
	 *            Long
	 * @return Contenido de AyudaAplicacion correspondiente al identificador
	 *         indicado.
	 */
	@RequestMapping(value = "getContenido", method = RequestMethod.POST)
	public @ResponseBody String getContenido(@RequestJsonBody Long idAyuda) {
		AyudaAplicacion ayudaAplicacion = new AyudaAplicacion();
		ayudaAplicacion.setIdAyuda(idAyuda);
		ayudaAplicacion = this.ayudaAplicacionService.find(ayudaAplicacion);
		AyudaAplicacionController.LOGGER
				.info("[GET - getContenido - findBy_PK] : Obtener Contenido de AyudaAplicacion por PK");

		String contenido = "";

		try {
			if (ayudaAplicacion.getContenido() != null) {
				contenido = ayudaAplicacion.getContenido();
			}
			AyudaAplicacionController.LOGGER.info("contenido: " + contenido);
		} catch (Exception e) {
			AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
		}

		return contenido;
	}

	/**
	 * Operacion CRUD Edit. Modificacion del bean indicado.
	 *
	 * @param ayuda
	 *            AyudaAplicacion Bean que contiene la informacion a modificar.
	 * @return AyudaAplicacion Bean resultante de la modificacion.
	 */
	@RequestMapping(value = "moveElement", method = RequestMethod.POST)
	public @ResponseBody AyudaAplicacion moveElement(@RequestJsonBody AyudaAplicacion ayuda) {

		List<AyudaAplicacion> listAyudasAplicacion = ayuda.getListaAyudas();

		for (AyudaAplicacion ayudaAplicacion : listAyudasAplicacion) {
			this.ayudaAplicacionService.move(ayudaAplicacion);
		}

		AyudaAplicacionController.LOGGER.info("[POST - moveElement] : AyudaAplicacion actualizado correctamente");

		return ayuda;
	}

	/**
	 * Devuelve el pdf de ayudas de la aplicación
	 * 
	 * @param response
	 *            HttpServletResponse.
	 */
	@RequestMapping(value = "generarPdf")
	public void service(HttpServletResponse response) {

		try {
			Locale locale = LocaleContextHolder.getLocale();

			String nombreFichero = this.messageSource.getMessage("nombre.fichero.ayudaAplicacion", null, locale);

			HeaderFooter hf = new HeaderFooter();
			Document document = new Document(PageSize.A4, 36, 36, 20 + hf.getTableHeight(), 45);

			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			PdfWriter writer = PdfWriter.getInstance(document, baos);
			writer.setLinearPageMode();
			TOCEvent event = new TOCEvent();
			writer.setPageEvent(event);
			writer.setPageEvent(hf);

			document.open();

			asignarDatosAyuda(document, writer);

			// TOC
			document.newPage();

			hf.setToc(true);

			// Número de páginas antes del TOC
			int numberPagesBeforeTOC = writer.getPageNumber();

			Font font = new Font();
			font.setSize(16);
			font.setColor(186, 25, 68);

			// Portada
			PdfPTable table = new PdfPTable(1);
			table.setTotalWidth(523);
			table.setLockedWidth(true);

			PdfPCell cell = new PdfPCell();
			cell.setBorder(Rectangle.NO_BORDER);
			cell.setHorizontalAlignment(Element.ALIGN_RIGHT);
			cell.setVerticalAlignment(Element.ALIGN_CENTER);

			Image image = Image.getInstance(this.getClass().getResource("images/itzulnet-manual-ayuda-portada.png"));
			cell.addElement(image);
			table.addCell(cell);

			table.writeSelectedRows(0, -1, document.left(), document.top() + hf.getTableHeight(),
					writer.getDirectContent());

			document.newPage();

			// Creación del índice
			Paragraph indice = new Paragraph();
			indice.add(new Chunk(this.messageSource.getMessage("label.indice", null, locale), font));
			indice.setAlignment(Element.ALIGN_CENTER);

			document.add(indice);

			this.asignarParrafo(document, event);

			document.newPage();

			// Ordenar las páginas
			this.ordenarPaginas(writer, numberPagesBeforeTOC);

			document.close();

			response.setContentType("application/pdf");
			response.setHeader("Content-disposition", "attachment;filename=\"" + nombreFichero + ".pdf\"");

			response.setHeader("Pragma", "cache");
			response.setHeader("Expires", "0");
			response.setHeader("Cache-Control", "private");

			Cookie cookie = new Cookie("fileDownload", "true");
			cookie.setPath("/");
			cookie.setSecure(true);
			response.addCookie(cookie);

			// the contentlength
			response.setContentLength(baos.size());
			// write ByteArrayOutputStream to the ServletOutputStream
			OutputStream os = response.getOutputStream();
			baos.writeTo(os);
			os.flush();
			os.close();
		} catch (Exception e) {
			AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
		}
	}

	/**
	 * @param document
	 * @param writer
	 * @throws SQLException
	 * @throws IOException
	 */
	private void asignarDatosAyuda(Document document, PdfWriter writer) throws SQLException, IOException {
		List<AyudaAplicacion> listAyudasAplicacion = this.ayudaAplicacionService.findAll(null);

		StringBuilder str = new StringBuilder(50);

		String estilosCSS = ".ayudaaplicacion-content { min-height: 100%; position: relative; font-family: Roboto, Verdana, sans-serif, -apple-system, system-ui; font-size: 10pt; color: #5b5b5b; line-height: 20px; position: relative; }";

		str.append("<html><head><style>");
		str.append(estilosCSS);
		str.append("</style></head><body>");
		str.append("<div class=\"ayudaaplicacion-content\">");

		for (AyudaAplicacion ayudaAplicacion : listAyudasAplicacion) {
			this.asignarTitulo(str, ayudaAplicacion);
			this.asignarContenido(str, ayudaAplicacion.getContenido());
		}

		str.append("</div>");
		str.append("</body></html>");

		CSSResolver cssResolver = XMLWorkerHelper.getInstance().getDefaultCssResolver(false);

		// HTML
		HtmlPipelineContext htmlContext = new HtmlPipelineContext(null);
		TagProcessorFactory factory = Tags.getHtmlTagProcessorFactory();
		factory.addProcessor(new Span() {
			@Override
			public List<Element> end(WorkerContext ctx, Tag tag, List<Element> l) {
				List<Element> list = new ArrayList<Element>(1);
				list.add(AyudaAplicacionController.this.getTitlesChungToc(ctx, tag.getAttributes()));
				return list;
			}
		}, "h1");
		htmlContext.setTagFactory(factory);

		htmlContext.setImageProvider(new Base64ImageProvider());
		htmlContext.autoBookmark(true);

		// Pipelines
		PdfWriterPipeline pdf = new PdfWriterPipeline(document, writer);
		HtmlPipeline html = new HtmlPipeline(htmlContext, pdf);
		CssResolverPipeline css = new CssResolverPipeline(cssResolver, html);

		// XML Worker
		XMLWorker worker = new XMLWorker(css, true);
		XMLParser p = new XMLParser(worker);
		p.parse(new ByteArrayInputStream(str.toString().getBytes()));
	}

	/**
	 * @param writer
	 * @param numberPagesBeforeTOC
	 * @throws DocumentException
	 */
	private void ordenarPaginas(PdfWriter writer, int numberPagesBeforeTOC) throws DocumentException {
		int numberPagesAfterTOC = writer.getPageNumber();
		int total = numberPagesAfterTOC - 1;
		int numberPagesToc = numberPagesAfterTOC - numberPagesBeforeTOC;
		int cont = 1;
		int[] order = new int[total];

		for (int i = 0; i < total; i++) {
			if (i < numberPagesToc) {
				order[i] = numberPagesAfterTOC - numberPagesToc + i;
			} else {
				order[i] = cont;
				cont++;
			}
		}
		writer.reorderPages(order);
	}

	/**
	 * @param document
	 * @param event
	 * @throws DocumentException
	 */
	private void asignarParrafo(Document document, TOCEvent event) throws DocumentException {
		Chunk dottedLine = new Chunk(new DottedLineSeparator());
		List<SimpleEntry<String, SimpleEntry<String, Integer>>> entries = event.getTOC();
		Paragraph para;
		for (SimpleEntry<String, SimpleEntry<String, Integer>> entry : entries) {
			Chunk chunk = this.obtenerChunk(entry.getKey());

			SimpleEntry<String, Integer> value = entry.getValue();
			chunk.setAction(PdfAction.gotoLocalPage(value.getKey(), false));
			para = new Paragraph(chunk);
			dottedLine.setAction(PdfAction.gotoLocalPage(value.getKey(), false));
			para.add(dottedLine);
			chunk = new Chunk(String.valueOf(value.getValue()));
			chunk.setAction(PdfAction.gotoLocalPage(value.getKey(), false));
			para.add(chunk);
			document.add(para);
		}
	}

	/**
	 * @param key
	 * @return Chunk
	 */
	private Chunk obtenerChunk(String key) {
		Chunk chunk = new Chunk();
		String tipo1 = "@TIPO=H1";
		String tipo2 = "@TIPO=H2";
		String tipo3 = "@TIPO=H3";
		String keyFinal = "";
		if (key.indexOf(tipo1) != -1) {
			keyFinal = key.replace(tipo1, "");
			chunk = new Chunk(keyFinal, new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.BOLD));
		} else if (key.indexOf(tipo2) != -1) {
			keyFinal = key.replace(tipo2, "");
			chunk = new Chunk(keyFinal, new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.NORMAL));
		} else if (key.indexOf(tipo3) != -1) {
			keyFinal = key.replace(tipo3, "");
			chunk = new Chunk(keyFinal, new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.ITALIC));
		}
		return chunk;
	}

	/**
	 * @param str
	 * @param contenido
	 * @throws SQLException
	 */
	public void asignarContenido(StringBuilder str, String contenido) throws SQLException {
		if (contenido != null) {
			str.append("<div>");
			str.append(contenido);
			str.append("</div>");
		}
		str.append("<br/>");
	}

	/**
	 * Asigna el título del nodo del árbol
	 * 
	 * @param str
	 * @param ayudaAplicacion
	 */
	private void asignarTitulo(StringBuilder str, AyudaAplicacion ayudaAplicacion) {
		String titulo = ayudaAplicacion.getTitulo();
		if (ayudaAplicacion.getLevel() == 1) {
			str.append("<h1 id=\"h1\" value='" + titulo + "'></h1>");
		} else if (ayudaAplicacion.getLevel() == 2) {
			str.append("<h1 id=\"h2\" value='" + titulo + "'></h1>");
		} else {
			str.append("<h1 id=\"h3\" value='" + titulo + "'></h1>");
		}
		str.append("<br/>");
	}

	public class HeaderFooter extends PdfPageEventHelper {

		private boolean esToc = false;

		public void setToc(boolean esToc) {
			this.esToc = esToc;
		}

		protected PdfPTable table;
		protected float tableHeight;

		public HeaderFooter() {
			this.table = new PdfPTable(2);
			this.table.setTotalWidth(523);
			this.table.setLockedWidth(true);

			try {
				Image image = Image.getInstance(this.getClass().getResource("images/ivap.png"));
				image.setAbsolutePosition(16, 0);

				Font font = new Font();
				font.setSize(16);
				font.setColor(186, 25, 68);
				Chunk header1 = new Chunk("Itzulnet", font);

				Phrase phraseHeader1 = new Phrase();
				phraseHeader1.add(header1);

				Paragraph pHeader1 = new Paragraph();
				pHeader1.add(phraseHeader1);
				pHeader1.setAlignment(Element.ALIGN_RIGHT);

				PdfPCell imageCell = new PdfPCell(image);
				imageCell.setVerticalAlignment(Element.ALIGN_MIDDLE);
				imageCell.setHorizontalAlignment(Element.ALIGN_LEFT);
				imageCell.setBorder(Rectangle.NO_BORDER);
				this.table.addCell(imageCell);

				PdfPCell textCell = new PdfPCell();
				textCell.addElement(pHeader1);
				textCell.setVerticalAlignment(Element.ALIGN_MIDDLE);
				textCell.setHorizontalAlignment(Element.ALIGN_RIGHT);
				textCell.setBorder(Rectangle.NO_BORDER);
				this.table.addCell(textCell);

				this.tableHeight = this.table.getTotalHeight();

			} catch (MalformedURLException e) {
				AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
			} catch (IOException e) {
				AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
			} catch (BadElementException e) {
				AyudaAplicacionController.LOGGER.error(e.getMessage(), e);
			}
		}

		public float getTableHeight() {
			return this.tableHeight;
		}

		@Override
		public void onEndPage(PdfWriter writer, Document document) {
			try {
				if (!this.esToc) {

					this.table.writeSelectedRows(0, -1, document.left(),
							document.top() + ((document.topMargin() + this.tableHeight) / 2),
							writer.getDirectContent());

					ColumnText ct = new ColumnText(writer.getDirectContent());

					Chunk footer = new Chunk(String.valueOf(writer.getPageNumber()));
					Phrase phraseFooter = new Phrase();
					phraseFooter.add(footer);

					Paragraph pFooter = new Paragraph();
					pFooter.add(phraseFooter);
					pFooter.setAlignment(Element.ALIGN_CENTER);

					ct.go();
					ct.setSimpleColumn(new Rectangle(36, 10, 559, 32));
					ct.addElement(pFooter);

					ct.go();
				}
			} catch (DocumentException de) {
				throw new ExceptionConverter(de);
			}
		}
	}

	public Chunk getTitlesChungToc(WorkerContext ctx, Map<String, String> attributes) {
		String value = attributes.get("value");
		String type = attributes.get("id");

		Font font = new Font();
		font.setSize(16);
		font.setColor(186, 25, 68);

		if ("h1".equals(type)) {
			Chunk c = new Chunk(value, font);
			c.setGenericTag(value + "@TIPO=H1");
			return c;
		} else if ("h2".equals(type)) {
			font.setSize(14);
			Chunk c = new Chunk(value, font);
			c.setGenericTag(value + "@TIPO=H2");
			return c;
		} else if ("h3".equals(type)) {
			font.setSize(12);
			Chunk c = new Chunk(value, font);
			c.setGenericTag(value + "@TIPO=H3");
			return c;
		}
		return null;
	}

	public class TOCEvent extends PdfPageEventHelper {

		protected int counter = 0;
		protected List<SimpleEntry<String, SimpleEntry<String, Integer>>> toc = new ArrayList<SimpleEntry<String, SimpleEntry<String, Integer>>>();

		@Override
		public void onGenericTag(PdfWriter writer, Document document, Rectangle rect, String text) {
			String name = "dest" + (this.counter++);
			int page = writer.getPageNumber();
			this.toc.add(new SimpleEntry<String, SimpleEntry<String, Integer>>(text,
					new SimpleEntry<String, Integer>(name, page)));
			writer.addNamedDestination(name, page, new PdfDestination(PdfDestination.FITH, rect.getTop()));
		}

		public List<SimpleEntry<String, SimpleEntry<String, Integer>>> getTOC() {
			return this.toc;
		}
	}

}
